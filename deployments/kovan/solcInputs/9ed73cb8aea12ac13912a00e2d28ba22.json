{
  "language": "Solidity",
  "sources": {
    "contracts/BurpToken/BurpERC20Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol';\n\ncontract BurpERC20Token is ERC20PresetFixedSupply {\n  constructor(\n    string memory name,\n    string memory symbol,\n    uint256 initialSupply,\n    address owner\n  ) public ERC20PresetFixedSupply(name, symbol, initialSupply, owner) { }\n\n}"
    },
    "@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../extensions/ERC20Burnable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - Preminted initial supply\n *  - Ability for holders to burn (destroy) their tokens\n *  - No access control mechanism (for minting/pausing) and hence no governance\n *\n * This contract uses {ERC20Burnable} to include burn capabilities - head to\n * its documentation for details.\n *\n * _Available since v3.4._\n */\ncontract ERC20PresetFixedSupply is ERC20Burnable {\n    /**\n     * @dev Mints `initialSupply` amount of token and transfers them to `owner`.\n     *\n     * See {ERC20-constructor}.\n     */\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        address owner\n    ) ERC20(name, symbol) {\n        _mint(owner, initialSupply);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 currentAllowance = allowance(account, _msgSender());\n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n        unchecked {\n            _approve(account, _msgSender(), currentAllowance - amount);\n        }\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][account] = accountBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Raffle/RaffleTicket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./RaffleAccessControl.sol\";\n\n\n/// @title A mintable NFT ticekt for Coinburp Raffle\n/// @author Gilbert Kim @gilbertk422\ncontract RaffleTicket is ERC1155, RaffleAccessControl {\n\tconstructor (string memory uri_) ERC1155(uri_) RaffleAccessControl(msg.sender, \"BURP_RAFFLE_TICKET\") {\n\n\t}\n\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, AccessControl) returns (bool) {\n\t\treturn super.supportsInterface(interfaceId);\n\t}\n\n\tfunction mint(address to, uint256 tokenId, uint256 amount) external onlyMinter {\n\t\tsuper._mint(to, tokenId, amount, '');\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/Raffle/RaffleAccessControl.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n\ncontract RaffleAccessControl is AccessControl {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\n  string public minterOf;\n\n  // Events\n  event MinterAdded(address indexed account, string minterOf);\n  event MinterRemoved(address indexed account, string minterOf);\n\n  modifier onlyAdmin() {\n    require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), \"Only admin role\");\n    _;\n  }\n  \n  modifier onlyMinter() {\n    require(hasRole(MINTER_ROLE, msg.sender), \"Only minter role\");\n    _;\n  }\n\n  /**\n   * @dev Constructor Add the given account both as the main Admin of the smart contract and a checkpoint minter\n   * @param mainMinter The account that will be added as mainMinter\n   */\n  constructor (address mainMinter, string memory _minterOf) {\n    require(\n      mainMinter != address(0),\n      \"Main minter should be a valid address\"\n    );\n\n    minterOf = _minterOf;\n    _setupRole(DEFAULT_ADMIN_ROLE, mainMinter);\n    _setupRole(MINTER_ROLE, mainMinter);\n\n    emit MinterAdded(mainMinter, minterOf);\n  }\n\n  /**\n   * @dev checks if the given account is a minter\n   * @param account The account that will be checked\n   */\n  function isMinter(address account) public view returns (bool) {\n    return hasRole(MINTER_ROLE, account);\n  }\n  \n  /**\n   * @dev Adds a new account to the minter role\n   * @param account The account that will have the minter role\n   */\n  function addMinter(address account) public onlyMinter virtual {\n    _setupRole(MINTER_ROLE, account);\n    \n    emit MinterAdded(account, minterOf);\n  }\n\n  /**\n   * @dev Removes the sender from the list the minter role\n   */\n  function renounceMinter() public {\n    renounceRole(MINTER_ROLE, msg.sender);\n\n    emit MinterRemoved(msg.sender, minterOf);\n  }\n\n  /**\n   * @dev Removes the given account from the minter role, if msg.sender is admin\n   * @param minter The account that will have the minter role removed\n   */\n  function removeMinter(address minter) public {\n    revokeRole(MINTER_ROLE, minter);\n\n    emit MinterRemoved(minter, minterOf);\n  }\n}\n"
    },
    "contracts/Raffle/Raffle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./IRaffle.sol\";\nimport \"../Chainlink/VRFConsumerBase.sol\";\n\n/// @title A provably fair NFT raffle\n/// @author Gilbert Kim @gilbertk422\ncontract Raffle is IRaffle, Ownable, IERC721Receiver, IERC1155Receiver, VRFConsumerBase {\n\tusing SafeMath for uint;\n\n\tbytes32 internal keyHash;\n\tuint256 internal fee;\n\n\tmapping(bytes32 => uint256) public randomnessRequests;\n\n\tRaffleInfo[] public raffleInfo;\n\n\tERC1155 public RaffleTicket;\n\n\tuint256 public withdrawGracePeriod;\n\n\tconstructor(\n\t\taddress raffleTicketAddress,\n\t\tbytes32 _keyHash,\n\t\taddress VRFCoordinator,\n\t\taddress LINKToken\n\t) VRFConsumerBase(\n\t\tVRFCoordinator, // VRF Coordinator\n\t\tLINKToken  // LINK Token\n\t) public {\n\t\tkeyHash = _keyHash;\n\t\tfee = 0.1 * 10 ** 18; // 0.1 LINK\n\n\t\tRaffleTicket = ERC1155(raffleTicketAddress);\n\t\twithdrawGracePeriod = 60 * 60 * 24 * 7; // 1 week in seconds\n\t}\n\n\tmodifier raffleExists(uint256 raffleIndex) {\n\t\trequire(raffleInfo.length > raffleIndex, 'Raffle: Raffle does not exists');\n\t\t_;\n\t}\n\n\tmodifier raffleIsRunning(uint256 raffleIndex) {\n\t\trequire(\n\t\t\traffleInfo[raffleIndex].startDate <= now() &&\n\t\t\tnow() <= raffleInfo[raffleIndex].endDate, 'Raffle: Raffle not running'\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier raffleIsConcluded(uint256 raffleIndex) {\n\t\trequire(now() >= raffleInfo[raffleIndex].endDate, 'Raffle: Raffle is not concluded yet');\n\t\t_;\n\t}\n\n\tmodifier raffleIsNotConcluded(uint256 raffleIndex) {\n\t\trequire(now() <= raffleInfo[raffleIndex].endDate, 'Raffle: Raffle is already concluded');\n\t\t_;\n\t}\n\n\t/**\n\t* @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n\t* by `operator` from `from`, this function is called.\n\t*\n\t* It must return its Solidity selector to confirm the token transfer.\n\t* If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n\t*\n\t* The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n\t*/\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) public virtual override returns (bytes4) {\n\t\treturn this.onERC721Received.selector;\n\t}\n\n\t/**\n\t* @dev Handles the receipt of a multiple ERC1155 token types. This function\n\t\tis called at the end of a `safeBatchTransferFrom` after the balances have\n\t\tbeen updated. To accept the transfer(s), this must return\n\t\t`bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n\t\t(i.e. 0xbc197c81, or its own function selector).\n\t* @param operator The address which initiated the batch transfer (i.e. msg.sender)\n\t* @param from The address which previously owned the token\n\t* @param ids An array containing ids of each token being transferred (order and length must match values array)\n\t* @param values An array containing amounts of each token being transferred (order and length must match ids array)\n\t* @param data Additional data with no specified format\n\t* @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n\t*/\n\tfunction onERC1155BatchReceived(address operator, address from, uint256[] memory ids, uint256[] memory values, bytes calldata data) public virtual override returns (bytes4) {\n\t\treturn this.onERC1155Received.selector;\n\t}\n\n\t/**\n\t*\t@dev Handles the receipt of a single ERC1155 token type. This function is\n\t\tcalled at the end of a `safeTransferFrom` after the balance has been updated.\n\t\tTo accept the transfer, this must return\n\t\t`bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n\t\t(i.e. 0xf23a6e61, or its own function selector).\n\t*\t@param operator The address which initiated the transfer (i.e. msg.sender)\n\t*\t@param from The address which previously owned the token\n\t*\t@param id The ID of the token being transferred\n\t*\t@param value The amount of tokens being transferred\n\t*\t@param data Additional data with no specified format\n\t*\t@return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n\t*/\n\tfunction onERC1155Received(address operator, address from, uint256 id, uint256 value, bytes calldata data) public virtual override returns (bytes4) {\n\t\treturn this.onERC1155Received.selector;\n\t}\n\n\t// ERC165 interface support\n\tfunction supportsInterface(bytes4 interfaceID) external view override returns (bool) {\n\t\t\treturn  interfaceID == 0x01ffc9a7 ||    // ERC165\n\t\t\t\t\t\t\tinterfaceID == 0x4e2312e0;      // ERC1155_ACCEPTED ^ ERC1155_BATCH_ACCEPTED;\n\t}\n\n\t/**\n\t* @dev Initiate a new raffle.\n\t* Only the Owner can call this method.\n\t* @param startDate The timestamp after when a raffle starts\n\t* @param endDate The timestamp after when a raffle can be finalised\n\t* @return (uint256) the index of the raffle\n\t*/\n\tfunction startRaffle(uint startDate, uint endDate) public override onlyOwner returns (uint256) {\n\t\trequire(startDate > now(), 'Raffle: Start date should be later than current block time');\n\t\trequire(startDate < endDate, 'Raffle: End date should be later than start date');\n\n\t\traffleInfo.push();\n\t\tuint256 newIndex = raffleInfo.length - 1;\n\n\t\traffleInfo[newIndex].startDate = startDate;\n\t\traffleInfo[newIndex].endDate = endDate;\n\t\traffleInfo[newIndex].randomResult = 0;\n\n\t\temit RaffleStarted(newIndex, startDate, endDate);\n\n\t\treturn newIndex;\n\t}\n\n\t/**\n\t* @dev This function helps to get a better picture of a given raffle. It also\n\t* @dev helps in verifying offchain the fairness of the Raffle.\n\t* @param raffleIndex The index of the Raffle to check.\n\t* @return (uint256) the number of players in the raffle\n\t*/\n\tfunction getPlayersLength(uint256 raffleIndex) public override view  returns (uint256) {\n\t\treturn raffleInfo[raffleIndex].players.length;\n\t}\n\n\t/**\n\t* @dev This function helps to get a better picture of a given raffle by\n\t* @dev helping retrieving the numebr of Prizes\n\t* @param raffleIndex The index of the Raffle to check.\n\t* @return (uint256) the number of prizes in the raffle\n\t*/\n\tfunction getPrizesLength(uint256 raffleIndex) public override view  returns (uint256) {\n\t\treturn raffleInfo[raffleIndex].prizes.length;\n\t}\n\n\t/**\n\t* @dev With this function the Owner can change the grace period\n\t* @dev to withdraw unclamed Prices\n\t* @param period The index of the Raffle to check.\n\t*/\n\tfunction changeWithdrawGracePeriod(uint256 period) public onlyOwner override {\n\t\twithdrawGracePeriod = period;\n\t}\n\n\t/**\n\t* @dev A handy getter for a Player of a given Raffle.\n\t* @param raffleIndex the index of the Raffle where to get the Player\n\t* @param playerIndex the index of the Player to get\n\t* @return (address) the address of the palayer\n\t*/\n\tfunction getPlayerAtIndex(\n\t\tuint256 raffleIndex,\n\t\tuint256 playerIndex\n\t)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\traffleExists(raffleIndex)\n\t\treturns (address)\n\t{\n\t\trequire(playerIndex < raffleInfo[raffleIndex].players.length, 'Raffle: No Player at index');\n\n\t\treturn raffleInfo[raffleIndex].players[playerIndex];\n\t}\n\n\t/**\n\t* @dev A handy getter for the Prizes\n\t* @param raffleIndex the index of the Raffle where to get the Player\n\t* @param prizeIndex the index of the Prize to get\n\t* @return (address, uint256) the prize address and the prize tokenId\n\t*/\n\tfunction getPrizeAtIndex(uint256 raffleIndex, uint256 prizeIndex) public override view returns (address, uint256) {\n\t\treturn (\n\t\t\traffleInfo[raffleIndex].prizes[prizeIndex].tokenAddress,\n\t\t\traffleInfo[raffleIndex].prizes[prizeIndex].tokenId\n\t\t);\n\t}\n\n\t/**\n\t * @dev This method disclosed the committed message and closes the current raffle.\n\t * Only the Owner can call this method\n\t * @param raffleIndex the index of the Raffle where to draft winners\n\t * @param entropy The message in clear. It will be used as part of entropy from Chainlink\n\t */\n\tfunction draftWinners(\n\t\tuint256 raffleIndex,\n\t\tuint256 entropy\n\t)\n\t\tpublic\n\t\toverride\n\t\tonlyOwner\n\t\traffleExists(raffleIndex)\n\t\traffleIsConcluded(raffleIndex)\n\t{\n\t\trequire(raffleInfo[raffleIndex].randomResult == 0, 'Raffle: Randomness already requested');\n\n\t\traffleInfo[raffleIndex].randomResult = 1; // 1 is our flag for 'pending'\n\n\t\tif(getPlayersLength(raffleIndex) > 0 && getPrizesLength(raffleIndex) > 0) {\n\t\t\tgetRandomNumber(raffleIndex, entropy);\n\t\t}\n\t\telse {\n\t\t\traffleInfo[raffleIndex].randomResult = 2; // 2 is our flag for 'concluded without Players'\n\n\t\t\temit WinnersDrafted(raffleIndex, 2);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Allows a winner to withdraw his/her prize\n\t * @param raffleIndex The index of the Raffle where to find the Price to withdraw\n\t * @param prizeIndex The index of the Prize to withdraw\n\t */\n\tfunction claimPrize(\n\t\tuint256 raffleIndex,\n\t\tuint prizeIndex\n\t)\n\t\tpublic\n\t\toverride\n\t\traffleExists(raffleIndex)\n\t\traffleIsConcluded(raffleIndex)\n\t{\n\t\trequire(\n\t\t\traffleInfo[raffleIndex].randomResult != 0 &&\n\t\t\traffleInfo[raffleIndex].randomResult != 1,\n\t\t\t'Raffle: Random Number not drafted yet'\n\t\t);\n\n\t\taddress prizeWinner = getPrizeWinner(raffleIndex, prizeIndex);\n\t\trequire(msg.sender == prizeWinner, 'Raffle: You are not the winner of this Prize');\n\n\t\t_transferPrize(raffleIndex, prizeIndex, prizeWinner);\n\t}\n\n\t/**\n\t* @dev It maps a given Prize with the address of the winner.\n\t* @param raffleIndex The index of the Raffle where to find the Price winner\n\t* @param prizeIndex The index of the prize to withdraw\n\t* @return (uint256) The index of the winnig account\n\t*/\n\tfunction getPrizeWinner(uint256 raffleIndex, uint256 prizeIndex) public override view  returns (address) {\n\t\tuint winnerIndex = getPrizeWinnerIndex(raffleIndex, prizeIndex);\n\n\t\treturn raffleInfo[raffleIndex].players[winnerIndex];\n\t}\n\n\t/**\n\t* @dev It maps a given Prize with the index of the winner.\n\t* @param raffleIndex The index of the Raffle where to find the Price winner\n\t* @param prizeIndex The index of the prize to withdraw\n\t* @return (uint256) The index of the winnig account\n\t*/\n\tfunction getPrizeWinnerIndex(\n\t\tuint256 raffleIndex,\n\t\tuint256 prizeIndex\n\t)\n\t\tpublic\n\t\toverride\n\t\tview\n\t\traffleIsConcluded(raffleIndex)\n\t\treturns (uint256)\n\t{\n\t\trequire(getPlayersLength(raffleIndex) > 0, 'Raffle: Raffle concluded without Players');\n\t\trequire(\n\t\t\traffleInfo[raffleIndex].randomResult != 0 &&\n\t\t\traffleInfo[raffleIndex].randomResult != 1,\n\t\t\t'Raffle: Randomness pending'\n\t\t);\n\n\t\tbytes32 randomNumber = keccak256(abi.encode(raffleInfo[raffleIndex].randomResult.add(prizeIndex)));\n\t\treturn uint(randomNumber).mod(getPlayersLength(raffleIndex));\n\t}\n\n\t/**\n\t * @dev Prevents locked NFT by allowing the Owner to withdraw an unclaimed\n\t * @dev prize after a grace period has passed\n\t * @param raffleIndex The index of the Raffle containing the Prize to withdraw\n\t * @param prizeIndex The index of the prize to withdraw\n\t */\n\tfunction unlockUnclaimedPrize(\n\t\tuint256 raffleIndex,\n\t\tuint prizeIndex\n\t)\n\t\tpublic\n\t\toverride\n\t\tonlyOwner\n\t\traffleIsConcluded(raffleIndex)\n\t{\n\t\trequire(\n\t\t\tnow() >= raffleInfo[raffleIndex].endDate.add(withdrawGracePeriod) ||\n\t\t\tgetPlayersLength(raffleIndex) == 0, // if there is no players, we can withdraw immediately\n\t\t\t'Raffle: Grace period not passed yet'\n\t\t);\n\n\t\t_transferPrize(raffleIndex, prizeIndex, msg.sender);\n\t}\n\n\t/**\n\t* @dev Once a non-ticket NFT is received, it is considered as prize\n\t* @dev play multiple tickets.\n\t* @notice MUST trigger PrizeAdded event\n\t* @dev With this function, we add the received NFT as raffle Prize\n\t* @param tokenAddress the address of the NFT received\n\t* @param tokenId the id of the NFT received\n\t*/\n\tfunction addPrize(\n\t\tuint256 raffleIndex,\n\t\taddress tokenAddress,\n\t\tuint256 tokenId\n\t)\n\t\tpublic\n\t\toverride\n\t\tonlyOwner\n\t\traffleExists(raffleIndex)\n\t\traffleIsNotConcluded(raffleIndex)\n\t{\n\t\trequire(tokenAddress != address(RaffleTicket), 'Raffle: Prize can not be a ticket');\n\n\t\tERC721 prizeInstance = ERC721(tokenAddress);\n\n\t\tprizeInstance.safeTransferFrom(msg.sender, address(this), tokenId);\n\n\t\tPrize memory prize;\n\t\tprize.tokenAddress = tokenAddress;\n\t\tprize.tokenId = tokenId;\n\n\t\traffleInfo[raffleIndex].prizes.push(prize);\n\n\t\tuint256 prizeIndex = raffleInfo[raffleIndex].prizes.length.sub(1);\n\n\t\temit PrizeAdded(raffleIndex, prizeIndex);\n\t}\n\n\t/**\n\t* @dev Anyone with a valid ticket can enter the raffle. One player can also\n\t* @dev play multiple tickets.\n\t* @notice MUST trigger EnteredGame event\n\t* @param raffleIndex The index of the Raffle to enter\n\t* @param ticketId the id of the Ticket spending the ticket to enter the game\n\t*/\n\tfunction enterGame(\n\t\tuint256 raffleIndex,\n\t\tuint256 ticketId\n\t)\n\t\tpublic\n\t\toverride\n\t\traffleExists(raffleIndex)\n\t\traffleIsRunning(raffleIndex)\n\t{\n\t\tRaffleTicket.safeTransferFrom(msg.sender, address(this), 0, 1, '');\n\n\t\traffleInfo[raffleIndex].players.push(msg.sender);\n\n\t\temit EnteredGame(raffleIndex, msg.sender, raffleInfo[raffleIndex].players.length.sub(1));\n\t}\n\n\t/**\n\t* @dev It transfers the prize to a given address.\n\t* @notice MUST trigger WinnersDrafted event\n\t* @param raffleIndex The index of the Raffle to enter\n\t* @param prizeIndex The index of the prize to withdraw\n\t* @param winnerAddress The address of the winner\n\t*/\n\tfunction _transferPrize(uint256 raffleIndex, uint prizeIndex, address winnerAddress) internal {\n\t\tPrize storage prize = raffleInfo[raffleIndex].prizes[prizeIndex];\n\n\t\tERC721 prizeInstance = ERC721(prize.tokenAddress);\n\n\t\tprizeInstance.safeTransferFrom(address(this), winnerAddress, prize.tokenId);\n\n\t\traffleInfo[raffleIndex].prizes[prizeIndex].claimed = true;\n\n\t\temit PrizeClaimed(raffleIndex, prizeIndex, winnerAddress);\n\t}\n\n\t/**\n\t* @dev Requests randomness from a user-provided seed\n\t* @param raffleIndex The index of the Raffle to to require randomness for\n\t* @param userProvidedSeed The seed provided by the Owner\n\t* @return requestId (bytes32) the request id\n\t*/\n\tfunction getRandomNumber(\n\t\tuint256 raffleIndex,\n\t\tuint256 userProvidedSeed\n\t)\n\t\tinternal\n\t\treturns (bytes32 requestId)\n\t{\n\t\trequire(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK - fill contract with faucet\");\n\n\t\tbytes32 requestId = requestRandomness(keyHash, fee, userProvidedSeed);\n\t\trandomnessRequests[requestId] = raffleIndex;\n\t\traffleInfo[raffleIndex].randomResult = 1; // a flag for pending randomness\n\n\t\treturn requestId;\n\t}\n\n\t/**\n\t* @dev Callback function used by VRF Coordinator\n\t* @notice MUST trigger WinnersDrafted event\n\t* @param requestId The id of the request being fulfilled\n\t* @param randomness The result of the randomness request\n\t*/\n\tfunction fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n\t\tuint256 raffleIndex = randomnessRequests[requestId];\n\n\t\trequire(raffleInfo[raffleIndex].randomResult == 1, 'Raffle: Request already fulfilled');\n\n\t\traffleInfo[raffleIndex].randomResult = randomness;\n\n\t\temit WinnersDrafted(randomnessRequests[requestId], randomness);\n\t}\n\n\t/**\n\t * @dev A simple time util\n\t * @return (uint256) current block timestamp\n\t */\n\tfunction now() internal view returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Raffle/IRaffle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\n/// @title A provably fair NFT raffle\n/// @author Gilbert Kim @gilbertk422\ninterface IRaffle {\n\tstruct Prize {\n\t\taddress tokenAddress;\n\t\tuint256 tokenId;\n\t\tbool claimed;\n\t}\n\n\tstruct RaffleInfo {\n\t\tuint endDate;\n\t\tuint startDate;\n\t\tPrize[] prizes;\n\t\taddress[] players;\n\t\tuint256 randomResult;\n\t}\n\n\tevent RaffleStarted(uint256 raffleIndex, uint indexed startDate, uint indexed endDate);\n\tevent EnteredGame(uint256 raffleIndex, address indexed player, uint256 playerIndexInRaffle);\n\tevent PrizeAdded(uint256 raffleIndex, uint256 prizeIndex);\n\tevent PrizeClaimed(uint256 raffleIndex, uint256 prizeIndex, address indexed winner);\n\tevent WinnersDrafted(uint256 raffleIndex, uint256 randomNumber);\n\n\t/**\n\t * @dev Initiate a new raffle. It should allow only when a raffle is not\n\t * already running. Only the Owner can call this method.\n\t * @param startDate The timestamp after when a raffle starts\n\t * @param endDate The timestamp after when a raffle can be finalised\n\t */\n\tfunction startRaffle(uint startDate, uint endDate) external returns (uint256);\n\n\t/**\n\t * @dev This function helps to get a better picture of a given raffle. It also\n\t * @dev helps in verifying offchain the fairness of the Raffle.\n\t * @param raffleIndex The index of the Raffle to check.\n\t */\n\tfunction getPlayersLength(uint256 raffleIndex) external view returns (uint256);\n\n\t/**\n\t * @dev This function helps to get a better picture of a given raffle by\n\t * @dev helping retrieving the numebr of Prizes\n\t * @param raffleIndex The index of the Raffle to check.\n\t */\n\tfunction getPrizesLength(uint256 raffleIndex) external view returns (uint256);\n\n\t/**\n\t * @dev With this function the Owner can change the grace period\n\t * @dev to withdraw unclamed Prices\n\t * @param period The index of the Raffle to check.\n\t */\n\tfunction changeWithdrawGracePeriod(uint256 period) external;\n\n\t/**\n\t * @dev A handy getter for a Player of a given Raffle.\n\t * @param raffleIndex the index of the Raffle where to get the Player\n\t * @param playerIndex the index of the Player to get\n\t */\n\tfunction getPlayerAtIndex(uint256 raffleIndex, uint256 playerIndex) external view returns (address);\n\n\t/**\n\t * @dev A handy getter for the Prizes\n\t * @param raffleIndex the index of the Raffle where to get the Player\n\t * @param prizeIndex the index of the Prize to get\n\t */\n\tfunction getPrizeAtIndex(uint256 raffleIndex, uint256 prizeIndex) external view returns (address, uint256);\n\n\t/**\n\t * @dev This method disclosed the committed message and closes the current raffle.\n\t * Only the Owner can call this method\n\t * @param raffleIndex the index of the Raffle where to draft winners\n\t * @param entropy The message in clear. It will be used as part of entropy from Chainlink\n\t */\n\tfunction draftWinners(uint256 raffleIndex, uint256 entropy) external;\n\n\t/**\n\t * @dev Allows a winner to withdraw his/her prize\n\t * @param raffleIndex The index of the Raffle where to find the Price to withdraw\n\t * @param prizeIndex The index of the Prize to withdraw\n\t */\n\tfunction claimPrize(uint256 raffleIndex, uint prizeIndex) external;\n\n\t\t/**\n\t * @dev It maps a given Prize with the address of the winner.\n\t * @param raffleIndex The index of the Raffle where to find the Price winner\n\t * @param prizeIndex The index of the prize to withdraw\n\t */\n\tfunction getPrizeWinner(uint256 raffleIndex, uint256 prizeIndex) external view returns (address);\n\n\t\t/**\n\t * @dev It maps a given Prize with the index of the winner.\n\t * @param raffleIndex The index of the Raffle where to find the Price winner\n\t * @param prizeIndex The index of the prize to withdraw\n\t */\n\tfunction getPrizeWinnerIndex(uint256 raffleIndex, uint256 prizeIndex) external view returns (uint256);\n\n\t/**\n\t * @dev Prevents locked NFT by allowing the Owner to withdraw an unclaimed\n\t * @dev prize after a grace period has passed\n\t * @param raffleIndex The index of the Raffle containing the Prize to withdraw\n\t * @param prizeIndex The index of the prize to withdraw\n\t */\n\tfunction unlockUnclaimedPrize(uint256 raffleIndex, uint prizeIndex) external;\n\n\t/**\n\t * @dev Once a non-ticket NFT is received, it is considered as prize\n\t * @dev play multiple tickets.\n\t * @dev With this function, we add the received NFT as raffle Prize\n\t * @param tokenAddress the address of the NFT received\n\t * @param tokenId the id of the NFT received\n\t */\n\tfunction addPrize(uint256 raffleIndex, address tokenAddress, uint256 tokenId) external;\n\n\t/**\n\t * @dev Anyone with a valid ticket can enter the raffle. One player can also\n\t * @dev play multiple tickets.\n\t * @param raffleIndex The index of the Raffle to enter\n\t * @param ticketId the id of the Ticket spending the ticket to enter the game\n\t */\n\tfunction enterGame(uint256 raffleIndex, uint256 ticketId) external;\n}"
    },
    "contracts/Chainlink/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./interfaces/ILinkToken.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n\n\tusing SafeMath for uint256;\n\n\tevent RandomnessRequested(bytes32 requestId);\n\n\t/**\n\t * @notice fulfillRandomness handles the VRF response. Your contract must\n\t * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n\t * @notice principles to keep in mind when implementing your fulfillRandomness\n\t * @notice method.\n\t *\n\t * @dev VRFConsumerBase expects its subcontracts to have a method with this\n\t * @dev signature, and will call it once it has verified the proof\n\t * @dev associated with the randomness. (It is triggered via a call to\n\t * @dev rawFulfillRandomness, below.)\n\t *\n\t * @param requestId The Id initially returned by requestRandomness\n\t * @param randomness the VRF output\n\t */\n\tfunction fulfillRandomness(bytes32 requestId, uint256 randomness)\n\t\tinternal virtual;\n\n\t/**\n\t * @notice requestRandomness initiates a request for VRF output given _seed\n\t *\n\t * @dev The fulfillRandomness method receives the output, once it's provided\n\t * @dev by the Oracle, and verified by the vrfCoordinator.\n\t *\n\t * @dev The _keyHash must already be registered with the VRFCoordinator, and\n\t * @dev the _fee must exceed the fee specified during registration of the\n\t * @dev _keyHash.\n\t *\n\t * @dev The _seed parameter is vestigial, and is kept only for API\n\t * @dev compatibility with older versions. It can't *hurt* to mix in some of\n\t * @dev your own randomness, here, but it's not necessary because the VRF\n\t * @dev oracle will mix the hash of the block containing your request into the\n\t * @dev VRF seed it ultimately uses.\n\t *\n\t * @param _keyHash ID of public key against which randomness is generated\n\t * @param _fee The amount of LINK to send with the request\n\t * @param _seed seed mixed into the input of the VRF.\n\t *\n\t * @return requestId unique ID for this request\n\t *\n\t * @dev The returned requestId can be used to distinguish responses to\n\t * @dev concurrent requests. It is passed as the first argument to\n\t * @dev fulfillRandomness.\n\t */\n\tfunction requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n\t\tinternal returns (bytes32 requestId)\n\t{\n\t\tLINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n\t\t// This is the seed passed to VRFCoordinator. The oracle will mix this with\n\t\t// the hash of the block containing this request to obtain the seed/input\n\t\t// which is finally passed to the VRF cryptographic machinery.\n\t\tuint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n\t\t// nonces[_keyHash] must stay in sync with\n\t\t// VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n\t\t// successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n\t\t// This provides protection against the user repeating their input seed,\n\t\t// which would result in a predictable/duplicate output, if multiple such\n\t\t// requests appeared in the same block.\n\t\tnonces[_keyHash] = nonces[_keyHash].add(1);\n\t\tbytes32 requestId = makeRequestId(_keyHash, vRFSeed);\n\n\t\temit RandomnessRequested(requestId);\n\n\t\treturn requestId;\n\t}\n\n\tILinkToken immutable internal LINK;\n\taddress immutable private vrfCoordinator;\n\n\t// Nonces for each VRF key from which randomness has been requested.\n\t//\n\t// Must stay in sync with VRFCoordinator[_keyHash][this]\n\tmapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n\n\t/**\n\t * @param _vrfCoordinator address of VRFCoordinator contract\n\t * @param _link address of LINK token contract\n\t *\n\t * @dev https://docs.chain.link/docs/link-token-contracts\n\t */\n\tconstructor(address _vrfCoordinator, address _link) {\n\t\tvrfCoordinator = _vrfCoordinator;\n\t\tLINK = ILinkToken(_link);\n\t}\n\n\t// rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n\t// proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n\t// the origin of the call\n\tfunction rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n\t\trequire(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n\t\tfulfillRandomness(requestId, randomness);\n\t}\n}"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/Chainlink/interfaces/ILinkToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILinkToken {\n\tfunction allowance(address owner, address spender) external view returns (uint256 remaining);\n\tfunction approve(address spender, uint256 value) external returns (bool success);\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\tfunction decimals() external view returns (uint8 decimalPlaces);\n\tfunction decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\tfunction increaseApproval(address spender, uint256 subtractedValue) external;\n\tfunction name() external view returns (string memory tokenName);\n\tfunction symbol() external view returns (string memory tokenSymbol);\n\tfunction totalSupply() external view returns (uint256 totalTokensIssued);\n\tfunction transfer(address to, uint256 value) external returns (bool success);\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool success);\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool success);\n}"
    },
    "contracts/Chainlink/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n\n\t/**\n\t * @notice returns the seed which is actually input to the VRF coordinator\n\t *\n\t * @dev To prevent repetition of VRF output due to repetition of the\n\t * @dev user-supplied seed, that seed is combined in a hash with the\n\t * @dev user-specific nonce, and the address of the consuming contract. The\n\t * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n\t * @dev the final seed, but the nonce does protect against repetition in\n\t * @dev requests which are included in a single block.\n\t *\n\t * @param _userSeed VRF seed input provided by user\n\t * @param _requester Address of the requesting contract\n\t * @param _nonce User-specific nonce at the time of the request\n\t */\n\tfunction makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n\t\taddress _requester, uint256 _nonce)\n\t\tinternal pure returns (uint256)\n\t{\n\t\treturn  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n\t}\n\n\t/**\n\t * @notice Returns the id for this request\n\t * @param _keyHash The serviceAgreement ID to be used for this request\n\t * @param _vRFInputSeed The seed to be passed directly to the VRF\n\t * @return The id for this request\n\t *\n\t * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n\t * @dev contract, but the one generated by makeVRFInputSeed\n\t */\n\tfunction makeRequestId(\n\t\tbytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n\t\treturn keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n\t}\n}"
    },
    "contracts/Raffle/RaffleVRFConsumer.sol": {
      "content": "\npragma solidity ^0.8.0;\n\nimport \"../Chainlink/VRFConsumerBase.sol\";\n\ncontract RaffleVRFConsumer is VRFConsumerBase {\n\tbytes32 internal keyHash;\n\tuint256 internal fee;\n\n\tuint256 public randomResult;\n\n\t/**\n\t * Constructor inherits VRFConsumerBase\n\t *\n\t * Network: Kovan\n\t * Chainlink VRF Coordinator address: 0xdD3782915140c8f3b190B5D67eAc6dc5760C46E9\n\t * LINK token address:                0xa36085F69e2889c224210F603D836748e7dC0088\n\t * Key Hash: 0x6c3699283bda56ad74f6b855546325b68d482e983852a7a82979cc4807b641f4\n\t */\n\tconstructor(\n\t\tbytes32 _keyhash,\n\t\taddress _vrfCoordinator,\n\t\taddress _linkToken\n\t) VRFConsumerBase(\n\t\t_vrfCoordinator, // VRF Coordinator\n\t\t_linkToken  // LINK Token\n\t) {\n\t\tkeyHash = _keyhash;\n\t\tfee = 0.1 * 10 ** 18; // 0.1 LINK\n\t}\n\n\t/**\n\t * Requests randomness from a user-provided seed\n\t */\n\tfunction getRandomNumber(uint256 userProvidedSeed) internal returns (bytes32 requestId) {\n\t\trequire(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK - fill contract with faucet\");\n\t\treturn requestRandomness(keyHash, fee, userProvidedSeed);\n\t}\n\n\t/**\n\t * Callback function used by VRF Coordinator\n\t */\n\tfunction fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n\t\trandomResult = randomness;\n\t}\n\n}"
    },
    "contracts/Chainlink/Mocks/VRFCoordinator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ILinkToken.sol\";\nimport \"../VRFConsumerBase.sol\";\n\ncontract VRFCoordinator {\n\n\tILinkToken public LINK;\n\n\tevent RandomnessRequest(address indexed sender, bytes32 indexed keyHash, uint256 indexed seed);\n\n\tconstructor(address linkAddress) public {\n\t\tLINK = ILinkToken(linkAddress);\n\t}\n\n\tfunction onTokenTransfer(address sender, uint256 fee, bytes memory _data)\n\t\tpublic\n\t\tonlyLINK\n\t{\n\t\t(bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n\t\temit RandomnessRequest(sender, keyHash, seed);\n\t}\n\n\tfunction callBackWithRandomness(\n\t\tbytes32 requestId,\n\t\tuint256 randomness,\n\t\taddress consumerContract\n\t) public {\n\t\tVRFConsumerBase v;\n\t\tbytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomness.selector, requestId, randomness);\n\t\tuint256 b = 206000;\n\t\trequire(gasleft() >= b, \"not enough gas for consumer\");\n\t\t(bool success,) = consumerContract.call(resp);\n\t}\n\n\tmodifier onlyLINK() {\n\t\trequire(msg.sender == address(LINK), \"Must use LINK token\");\n\t\t_;\n\t}\n}"
    },
    "contracts/NFTRarityRegister/NFTRarityRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./INFTRarityRegister.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/// @title Registry holding the rarity value of a given NFT.\n/// @author Gilbert Kim @gilbertk422\ncontract NFTRarityRegister is INFTRarityRegister, Ownable {\n\tusing SafeMath for uint;\n\n\tmapping(address => mapping(uint256 => uint8)) private rarityRegister;\n\n\t/**\n\t * @dev Store the rarity of a given NFT\n\t * @param tokenAddress The NFT smart contract address e.g., ERC-721 standard contract\n\t * @param tokenId The NFT's unique token id\n\t * @param rarityValue The rarity of a given NFT address and id unique combination\n\t * using percentage i.e., 100% = 1000 to correct for precision and\n\t * to save gas required when converting from category, e.g.,\n\t * high, medium, low to percentage in staking contract\n\t * can apply rarityValue on interests directly after fetching\n\t */\n\tfunction storeNftRarity(address tokenAddress, uint tokenId, uint8 rarityValue) external override onlyOwner {\n\t\t// check tokenAddress, tokenId and rarityValue are valid\n\t\t// _exists ERC721 function is internal\n\t\trequire(tokenAddress != address(0), \"NFTRarityRegister: Token address is invalid\");\n\t\trequire(getNftRarity(tokenAddress, tokenId) == 0, \"NFTRarityRegister: Rarity already set for token\");\n\t\trequire(rarityValue >= 100, \"NFTRarityRegister: Value must be at least 100\");\n\n\t\trarityRegister[tokenAddress][tokenId] = rarityValue;\n\n\t\temit NftRarityStored(tokenAddress, tokenId, rarityValue);\n\t}\n\n\t/**\n\t * @dev Get the rarity of a given NFT\n\t * @param tokenAddress The NFT smart contract address e.g., ERC-721 standard contract\n\t * @param tokenId The NFT's unique token id\n\t * @return The the rarity of a given NFT address and id unique combination and timestamp\n\t */\n\tfunction getNftRarity(address tokenAddress, uint256 tokenId) public override view returns (uint8) {\n\t\treturn rarityRegister[tokenAddress][tokenId];\n\t}\n}"
    },
    "contracts/NFTRarityRegister/INFTRarityRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Registry holding the rarity value of a given NFT.\n/// @author Gilbert Kim @gilbertk422\ninterface INFTRarityRegister {\n\t/**\n\t * The Staking SC allows to stake Prizes won via lottery which can be used to increase the APY of\n\t * staked tokens according to the rarity of NFT staked. For this reason,\n\t * we need to hold a table that the Staking SC can query and get back the rarity value of a given\n\t * NFT price (even the ones in the past).\n\t */\n\tevent NftRarityStored(\n\t\taddress indexed tokenAddress,\n\t\tuint256 tokenId,\n\t\tuint256 rarityValue\n\t);\n\n\t/**\n\t * @dev Store the rarity of a given NFT\n\t * @param tokenAddress The NFT smart contract address e.g., ERC-721 standard contract\n\t * @param tokenId The NFT's unique token id\n\t * @param rarityValue The rarity of a given NFT address and id unique combination\n\t */\n\tfunction storeNftRarity(address tokenAddress, uint256 tokenId, uint8 rarityValue) external;\n\n\t/**\n\t * @dev Get the rarity of a given NFT\n\t * @param tokenAddress The NFT smart contract address e.g., ERC-721 standard contract\n\t * @param tokenId The NFT's unique token id\n\t * @return The the rarity of a given NFT address and id unique combination and timestamp\n\t */\n\tfunction getNftRarity(address tokenAddress, uint256 tokenId) external view returns (uint8);\n}\n"
    },
    "contracts/Staking/StakingLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../NFTRarityRegister/INFTRarityRegister.sol\";\n\nimport \"../Raffle/IRaffleTicket.sol\";\nimport \"./RewardStreamerLib.sol\";\n\nimport \"./TokenHelper.sol\";\n\nlibrary StakingLib {\n\tusing SafeMath for uint256;\n  // **************************\n\t// **| StakingLib section |**\n  // **************************\n\n\tstruct StakingInfo {\n\t\tuint256 historyStartBlock; // this is set only when we deploy the contract\n\t\tuint256 historyEndBlock; // it starts and finishes in the same block (so length is 0)\n\t\tuint256 historyAverageReward; // how many reward tokens (in Wei) we give PER TOKEN STAKED PER BLOCK\n\t\tuint256 historyRewardPot; // the tokens unclaimed from history\n\n\t\tuint256 totalCurrentlyStaked; // the actual amount of $BURP tokens sent from users\n\t\tuint256 totalStakingUnits; // sum of all user stake shares\n\n\t\tuint256 totalDistributedRewards; // sum of all distributed rewards, mainly helpful for testing\n\n\t\tuint256[] locks;\n\t\tuint256[] locksMultiplier;\n\n\t\tuint256 ticketsMintingRatio;\n\t\tuint256 ticketsMintingChillPeriod;\n\n\t\taddress ticket;\n\t\taddress rarityRegister;\n\t}\n\n\t/**\n\t* @notice Will get the lock duration from the stake bytes data\n\t* @dev the bytes should contain the index of the lock in the first 32 bytes\n\t* @dev the index should be < locks.length\n\t* @param data bytes from the stake action\n\t* @return uint256 The duration of the lock (time for wich the stake will be locked)\n\t*/\n\tfunction getLockDuration(StakingInfo storage stakingInfo, bytes memory data) public view returns (uint256, uint256) {\n\t\trequire(data.length >= 32, 'Stake: data should by at least 32 bytes');\n\n\t\tuint256 lengthIndex = getStakeIndexFromCalldata(data);\n\n\t\trequire(lengthIndex < stakingInfo.locks.length, 'Stake: lock index out of bounds');\n\n\t\treturn (stakingInfo.locks[lengthIndex], lengthIndex);\n\t}\n\n\t/**\n\t* @notice Will calculate the current period length\n\t* @return (uint256) The current period length\n\t*/\n\tfunction getCurrentPeriodLength(StakingInfo storage stakingInfo) public view returns(uint256) {\n\t\treturn uint256(block.number).sub(stakingInfo.historyEndBlock);\n\t}\n\n\t/**\n\t* @notice Will calculate the current period length optionaly including the last block\n\t* @param excludeLast a flag that indicates to include the last block or not\n\t* @return (uint256) The current period length\n\t*/\n\tfunction getCurrentPeriodLength(StakingInfo storage stakingInfo, bool excludeLast) public view returns(uint256) {\n\t\treturn excludeLast ? getCurrentPeriodLength(stakingInfo).sub(1) : getCurrentPeriodLength(stakingInfo);\n\t}\n\n\t/**\n\t* @notice Will calculate the history length in blocks\n\t* @return (uint256) The history length\n\t*/\n\tfunction getHistoryLength(StakingInfo storage stakingInfo) public view returns (uint256){\n\t\treturn stakingInfo.historyEndBlock.sub(stakingInfo.historyStartBlock);\n\t}\n\n\t/**\n\t* @notice Calculate the average reward for the current period\n\t* @param stakingInfo the struct containing staking info\n\t* @param totalReward the total reward in current period\n\t* @param excludeLast wether or not exclude the last block\n\t* @return (uint256) number of blocks in history\n\t*/\n\tfunction getCurrentPeriodAverageReward(\n\t\tStakingInfo storage stakingInfo,\n\t\tuint256 totalReward,\n\t\tbool excludeLast\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakingInfo.totalStakingUnits == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 currentPeriodLength = getCurrentPeriodLength(stakingInfo, excludeLast);\n\t\tif(currentPeriodLength == 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn totalReward\n\t\t\t.mul(10**18)\n\t\t\t.div(stakingInfo.totalStakingUnits)\n\t\t\t.div(currentPeriodLength);\n\t}\n\n\t/**\n\t* @notice Calculate the total generated reward for a period\n\t* @param _block the current block\n\t* @param historyStartBlock the first history block\n\t* @param rewardPerBlock the amount of tokens rewarded per block\n\t* @return (uint256) number of blocks in history\n\t*/\n\tfunction totalGeneratedReward(uint256 _block, uint256 historyStartBlock, uint256 rewardPerBlock) public pure returns(uint256) {\n\t\treturn (_block.sub(historyStartBlock)).mul(rewardPerBlock);\n\t}\n\n\t/**\n\t* @notice Calculate the reward from current period\n\t* @param totalRewardInCurrentPeriod the total reward from current period\n\t* @param totalStakingUnits sum of all user stake shares\n\t* @return (uint256) the calculater reward\n\t*/\n\tfunction _stakerRewardFromCurrentPeriod(\n\t\tuint256 totalRewardInCurrentPeriod,\n\t\tuint256 stakerBalance,\n\t\tuint256 totalStakingUnits\n\t)\n\t\tprivate\n\t\tpure\n\t\treturns(uint256)\n\t{\n\t\treturn totalRewardInCurrentPeriod\n\t\t\t.mul(stakerBalance)\n\t\t\t.div(totalStakingUnits);\n\t}\n\n\t/**\n\t* @notice Calculate the reward from current period\n\t* @return (uint256) the calculater reward\n\t*/\n\tfunction getStakerRewardFromCurrentPeriod(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 stakerBalance = userStakes[stakeIndex].stakingUnits;\n\t\tuint256\ttotalRewardInCurrentPeriod = RewardStreamerLib.unsafeGetRewardsFromRange(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo.historyEndBlock,\n\t\t\tblock.number\n\t\t);\n\n\t\treturn _stakerRewardFromCurrentPeriod(\n\t\t\ttotalRewardInCurrentPeriod,\n\t\t\tstakerBalance,\n\t\t\tstakingInfo.totalStakingUnits\n\t\t);\n\t}\n\n\t/**\n\t* @notice Calculate the reward from current period\n\t* @return (uint256) the calculater reward\n\t*/\n\tfunction getStakerRewardFromCurrentPeriod(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex,\n\t\tbool excludeLast\n\t)\n\t\tprivate\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 stakerBalance = userStakes[stakeIndex].stakingUnits;\n\t\tuint256\ttotalRewardInCurrentPeriod = RewardStreamerLib.getRewardAndUpdateCursor(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo.historyEndBlock,\n\t\t\tblock.number.sub(1)\n\t\t);\n\n\n\t\treturn _stakerRewardFromCurrentPeriod(\n\t\t\ttotalRewardInCurrentPeriod,\n\t\t\tstakerBalance,\n\t\t\tstakingInfo.totalStakingUnits\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate and return the total reward user has accumulated till now for a specific stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The total rewards acumulated till now\n\t*/\n\tfunction getStakerReward(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 currentPeriodReward = getStakerRewardFromCurrentPeriod(rewardStreamInfo, stakingInfo, userStakes, stakeIndex);\n\t\tuint256 historyPeriodReward = getStakerRewardFromHistory(stakingInfo, userStakes, stakeIndex);\n\n\t\treturn currentPeriodReward.add(historyPeriodReward);\n\t}\n\n\t/**\n\t* @notice Will calculate and return the total reward user has accumulated till now for a specific stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The total rewards acumulated till now\n\t*/\n\tfunction _getStakerReward(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tprivate\n\t\treturns (uint256)\n\t{\n\t\tuint256 currentPeriodReward = getStakerRewardFromCurrentPeriod(rewardStreamInfo, stakingInfo, userStakes, stakeIndex, true);\n\t\tuint256 historyPeriodReward = getStakerRewardFromHistory(stakingInfo, userStakes, stakeIndex);\n\n\t\treturn currentPeriodReward.add(historyPeriodReward);\n\t}\n\n\t/**\n\t* @notice Creates a stake instance for the staker\n\t* @notice MUST trigger Staked event\n\t* @dev The NFT should be in the rarityRegister\n\t* @dev For each stake you can have only one NFT staked\n\t* @param amountStaked the number of tokens to be staked\n\t* @param blockNumber the block number at which the stake is created\n\t* @param lockDuration the duration for which the tokens will be locked\n\t*/\n\tfunction addStake(\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 amountStaked,\n\t\tuint256 stakingUnits,\n\t\tuint256 blockNumber,\n\t\tuint256 lockDuration\n\t)\n\t\tprivate\n\t{\n\t\tuserStakes.push(UserStake({\n\t\t\t\tamountStaked: amountStaked,\n\t\t\t\tstakingUnits: stakingUnits,\n\t\t\t\tenteredAtBlock: blockNumber,\n\t\t\t\thistoryAverageRewardWhenEntered: stakingInfo.historyAverageReward,\n\t\t\t\tticketsMintingRatioWhenEntered: stakingInfo.ticketsMintingRatio,\n\t\t\t\tticketsMintingChillPeriodWhenEntered: stakingInfo.ticketsMintingChillPeriod,\n\t\t\t\tlockedTill: blockNumber.add(lockDuration),\n\t\t\t\trewardCredit: 0,\n\t\t\t\tticketsMinted: 0,\n\t\t\t\tuserStakedToken: StakingLib.UserStakedToken({\n\t\t\t\t\ttokenAddress: address(0),\n\t\t\t\t\ttokenId: 0\n\t\t\t\t})\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t* @notice Allows user to stake tokens\n\t* @notice Optionaly user can stake a NFT token for extra reward\n\t* @dev Users wil be able to unstake only after the lock durationn has pased.\n\t* @dev The lock duration in the data bytes is required, its the index of the locks array\n\t* Should be the fist 32 bytes in the bytes array\n\t* @param amount the inumber of tokens to be staked\n\t* @param data the bytes containig extra information about the staking\n\t* lock duration index: fist 32 bytes (Number) - Required\n\t* NFT address: next 20 bytes (address)\n\t* NFT tokenId: next 32 bytes (Number)\n\t*/\n\tfunction stake(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\taddress staker,\n\t\tuint256 amount,\n\t\tbytes calldata data\n\t)\n\t\tpublic\n\t{\n\t\t\t(uint256 lockDuration, uint256 lockIndex) = getLockDuration(stakingInfo, data);\n\n\t\t\tTokenHelper.ERC20TransferFrom(address(rewardStreamInfo.rewardToken), msg.sender, address(this), amount);\n\n\t\t\tupdateHistoryValues(rewardStreamInfo, stakingInfo);\n\n\t\t\tuint256 durationMultiplier = stakingInfo.locksMultiplier[lockIndex];\n\n\t\t\t// when staking without any multiplier, staking units and amount are identical\n\t\t\tstakingInfo.totalStakingUnits = stakingInfo.totalStakingUnits.add(applyPercent(amount, durationMultiplier));\n\t\t\tstakingInfo.totalCurrentlyStaked = stakingInfo.totalCurrentlyStaked.add(amount);\n\n\t\t\taddStake(stakingInfo, userStakes, amount, applyPercent(amount, durationMultiplier), block.number, lockDuration);\n\n\t\t\tif (data.length >= 84) { // [32, 20. 32] == [index, address, tokenId]\n\t\t\t\taddNftToStake(\n\t\t\t\t\trewardStreamInfo,\n\t\t\t\t\tstakingInfo,\n\t\t\t\t\tuserStakes,\n\t\t\t\t\tuserStakes.length.sub(1),\n\t\t\t\t\tgetTokenAddressFromCalldata(data),\n\t\t\t\t\tgetTokenIdFromCalldata(data)\n\t\t\t\t);\n\t\t\t}\n\t\t\tclaimTickets(\n\t\t\t\tstakingInfo.ticket,\n\t\t\t\tuserStakes[userStakes.length.sub(1)], // last stake just created\n\t\t\t\tstaker\n\t\t\t);\n\t}\n\n\t/**\n\t* @notice Calculate the new history reward pot\n\t* @param oldHistoryRewardPot the old history reward pot\n\t* @param totalRewardInCurrentPeriod the total reward from current period\n\t* @param stakerReward the staker reward\n\t* @return (uint256) the new history reward pot\n\t*/\n\tfunction historyRewardPot(\n\t\tuint256 oldHistoryRewardPot,\n\t\tuint256 totalRewardInCurrentPeriod,\n\t\tuint256 stakerReward\n\t) public pure returns(uint256) {\n\t\treturn oldHistoryRewardPot\n\t\t\t.add(totalRewardInCurrentPeriod)\n\t\t\t.sub(stakerReward);\n\t}\n\n\t/**\n\t* @notice Will parse bytes data to get an uint256\n\t* @param data bytes data\n\t* @param from from where to start the parsing\n\t*/\n\tfunction parse32BytesToUint256(bytes memory data, uint256 from) public pure returns (uint256 parsed){\n\t\tassembly {parsed := mload(add(add(data, from), 32))}\n\t}\n\n\t/**\n\t* @notice Will parse bytes data to get an address\n\t* @param data bytes data\n\t* @param from from where to start the parsing\n\t*/\n\tfunction parseBytesToAddress(bytes memory data, uint256 from) public pure returns (address parsed){\n\t\tassembly {parsed := mload(add(add(data, from), 20))}\n\t}\n\n\t/**\n\t* @notice Will parse the stake bytes data to get the stake index\n\t* @dev [(index 32 bytes), (nft address 20 bytes), (tokenId 32 bytes)]\n\t* @param data bytes from the stake action\n\t* @return (uint256) the parsed index\n\t*/\n\tfunction getStakeIndexFromCalldata(bytes memory data) public pure returns (uint256) {\n\t\treturn parse32BytesToUint256(data, 0);\n\t}\n\n\t/**\n\t* @notice Will parse the stake bytes data to get the NFT address\n\t* @dev [(index 32 bytes), (nft address 20 bytes), (tokenId 32 bytes)]\n\t* @param data bytes from the stake action\n\t* @return (address) the parsed address\n\t*/\n\tfunction getTokenAddressFromCalldata(bytes memory data) public pure returns (address) {\n\t\treturn parseBytesToAddress(data, 32);\n\t}\n\n\t/**\n\t* @notice Will parse the stake bytes data to get the NFT tokeId\n\t* @dev [(index 32 bytes), (nft address 20 bytes), (tokenId 32 bytes)]\n\t* @param data bytes from the stake action\n\t* @return (uint256) the parsed tokenId\n\t*/\n\tfunction getTokenIdFromCalldata(bytes memory data) public pure returns (uint256) {\n\t\treturn parse32BytesToUint256(data, 52);\n\t}\n\n\t/**\n\t* @notice Will apply a percentage to a number\n\t* @param number The number to multiply\n\t* @param percent The percentage to apply\n\t* @return (uint256) the operation result\n\t*/\n\tfunction applyPercent(uint256 number, uint256 percent) public pure returns (uint256) {\n\t\treturn number.mul(percent).div(100);\n\t}\n\n\t/**\n\t* @notice Calculates the new History Average Reward\n\t* @dev this is called **before** we update history end block\n\t* @return uint256 The calculated newHistoryAverageReward\n\t*/\n\tfunction getNewHistoryAverageReward(\n\t\tuint256 currentPeriodLength,\n\t\tuint256 currentPeriodAverageReward,\n\t\tuint256 currentHistoryLength,\n\t\tuint256 historyStartBlock,\n\t\tuint256 historyAverageReward\n\t) public view returns (uint256) {\n\t\tuint256 blockNumber = block.number;\n\t\tuint256 newHistoryLength = uint256(blockNumber).sub(1).sub(historyStartBlock);\n\n\t\tuint256 fromCurrent = currentPeriodLength.mul(currentPeriodAverageReward);\n\t\tuint256 fromHistory = currentHistoryLength.mul(historyAverageReward);\n\n\t\tuint256 newHistoryAverageReward = (\n\t\t\t(fromCurrent).add(fromHistory)\n\t\t)\n\t\t.div(newHistoryLength);\n\n\t\treturn newHistoryAverageReward;\n\t}\n\n\tfunction updateHistoryValues(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo\n\t)\n\t\tpublic\n\t{\n\t\tuint256 totalRewardInCurrentPeriod = RewardStreamerLib.getRewardAndUpdateCursor(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo.historyEndBlock,\n\t\t\tblock.number.sub(1)\n\t\t);\n\t\tuint256 currentPeriodAverageReward = getCurrentPeriodAverageReward(\n\t\t\tstakingInfo,\n\t\t\ttotalRewardInCurrentPeriod,\n\t\t\ttrue\n\t\t);\n\n\t\t// 1. we update the stakingInfo.historyAverageReward with the WEIGHTED average of history reward and current reward\n\t\tstakingInfo.historyAverageReward = getNewHistoryAverageReward(\n\t\t\tgetCurrentPeriodLength(stakingInfo, true),\n\t\t\tcurrentPeriodAverageReward,\n\t\t\tgetHistoryLength(stakingInfo),\n\t\t\tstakingInfo.historyStartBlock,\n\t\t\tstakingInfo.historyAverageReward\n\t\t);\n\n\t\t// 2. we push the currentPeriodReward in the history\n\t\tstakingInfo.historyRewardPot = historyRewardPot(\n\t\t\t\tstakingInfo.historyRewardPot,\n\t\t\t\ttotalRewardInCurrentPeriod,\n\t\t\t\t0\n\t\t\t);\n\n\t\t// 3. we update the stakingInfo.historyEndBlock;\n\t\tstakingInfo.historyEndBlock = uint256(block.number).sub(1);\n\t}\n\n\tfunction setTicketsMintingRatio(\n\t\tStakingInfo storage stakingInfo,\n\t\tuint256 mintingRatio\n\t)\n\t\tpublic\n\t{\n\t\tstakingInfo.ticketsMintingRatio = mintingRatio;\n\t}\n\n  // *****************************\n\t// *** UserStakesLib section ***\n\t// *****************************\n\n\tstruct UserStakedToken {\n\t\taddress tokenAddress;\n\t\tuint256 tokenId;\n\t}\n\n\tstruct UserStake {\n\t\tuint256 stakingUnits;\n\t\tuint256 amountStaked;\n\t\tuint256 enteredAtBlock;\n\t\tuint256 historyAverageRewardWhenEntered;\n\t\tuint256 ticketsMintingRatioWhenEntered;\n\t\tuint256 ticketsMintingChillPeriodWhenEntered;\n\t\tuint256 lockedTill;\n\t\tuint256 rewardCredit;\n\t\tuint256 ticketsMinted;\n\t\tUserStakedToken userStakedToken;\n\t}\n\n\tfunction getTotalStakedFor(\n\t\tUserStake[] storage userStakes\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 total;\n\n\t\tfor (uint i = 0; i < userStakes.length; i++) {\n\t\t\ttotal = total.add(userStakes[i].amountStaked);\n\t\t}\n\n\t\treturn total;\n\t}\n\n\t\t/**\n\t* @notice Calculate the staker time in history\n\t* @return (uint256) number of blocks in history\n\t*/\n\tfunction getStakerTimeInHistory(\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length || userStakes[stakeIndex].enteredAtBlock == 0 || userStakes[stakeIndex].enteredAtBlock > stakingInfo.historyEndBlock) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn stakingInfo.historyEndBlock.sub(userStakes[stakeIndex].enteredAtBlock).add(1);\n\t}\n\n\t/**\n\t* @notice Will calculate and return what the history length was a the moment the stake was created\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The length of the history\n\t*/\n\tfunction getHistoryLengthBeforeStakerEntered(\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 enteredAtBlock = userStakes[stakeIndex].enteredAtBlock;\n\n\t\tif (enteredAtBlock == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn enteredAtBlock.sub(stakingInfo.historyStartBlock).sub(1);\n\t}\n\n\t/**\n\t* @notice Calculate the user share in the pool\n\t* @param totalStakingUnits sum of all user stake shares\n\t* @return (uint256) the calculater pool share\n\t*/\n\tfunction userPoolShare(\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex,\n\t\tuint256 totalStakingUnits\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length || userStakes[stakeIndex].stakingUnits == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 stakerBalance = userStakes[stakeIndex].stakingUnits;\n\n\t\treturn stakerBalance.mul(10**18).div(totalStakingUnits);\n\t}\n\n\t/**\n\t* @notice Calculate the history average for staker\n\t* @return (uint256) the calculated average\n\t*/\n\tfunction getHistoryAverageForStaker(\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 historyAverageRewardWhenEntered = userStakes[stakeIndex].historyAverageRewardWhenEntered;\n\t\tuint256 blocksParticipatedInHistory = getStakerTimeInHistory(\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\n\t\tif(blocksParticipatedInHistory == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 historyLength = getHistoryLength(stakingInfo);\n\n\t\tuint256 historyLengthBeforeStakerEntered = getHistoryLengthBeforeStakerEntered(\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\n\t\treturn stakingInfo.historyAverageReward\n\t\t\t.mul(historyLength)\n\t\t\t.sub(\n\t\t\t\thistoryAverageRewardWhenEntered.mul(historyLengthBeforeStakerEntered)\n\t\t\t).div(blocksParticipatedInHistory);\n\n\t}\n\n\t/**\n\t* @notice Calculate the stake reward from history\n\t* @return (uint256) the calculater reward\n\t*/\n\tfunction getStakerRewardFromHistory(\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns(uint256)\n\t{\n\t\tif (stakeIndex >= userStakes.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 stakingUnits = userStakes[stakeIndex].stakingUnits;\n\t\tif (stakingUnits == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tuint256 historyAverageForStaker = getHistoryAverageForStaker(\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\t\tuint256 blocksParticipatedInHistory = getStakerTimeInHistory(\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\n\t\treturn blocksParticipatedInHistory\n\t\t\t.mul(historyAverageForStaker)\n\t\t\t.mul(stakingUnits)\n\t\t\t.div(10 ** 18);\n\t}\n\n\t/**\n\t* @notice Allows user to stake an nft to an existing stake for extra reward\n\t* @dev The NFT should be in the rarityRegister\n\t* @dev For each stake you can have only one NFT staked\n\t*/\n\tfunction _addNftToStakeAndApplyMultiplier(\n\t\taddress rarityRegister,\n\t\tUserStake storage userStake,\n\t\taddress tokenAddress,\n\t\tuint256 tokenId\n\t)\n\t\tprivate\n\t{\n\t\tuint256 rewardMultiplier = INFTRarityRegister(rarityRegister).getNftRarity(tokenAddress, tokenId);\n\n\t\trequire(rewardMultiplier > 0, 'Staking: NFT not found in RarityRegister');\n\t\trequire(rewardMultiplier >= 100, 'Staking: NFT multiplier must be at least 100');\n\t\trequire(\n\t\t\tuserStake.userStakedToken.tokenAddress == address(0),\n\t\t\t'Staking: Stake already has a token'\n\t\t);\n\t\trequire(\n\t\t\tuserStake.lockedTill > block.number,\n\t\t\t'Staking: cannot add NFT to unlocked stakes'\n\t\t);\n\n\n\t\tuint userStakingUnits = userStake.stakingUnits;\n\n\t\tbool success = TokenHelper.transferFrom(tokenAddress, tokenId, msg.sender, address(this));\n\n\t\trequire(success, \"Staking: could not add NFT to stake\");\n\n\t\tuserStake.userStakedToken.tokenAddress = tokenAddress;\n\t\tuserStake.userStakedToken.tokenId = tokenId;\n\n\t\tuserStake.stakingUnits = applyPercent(userStakingUnits, rewardMultiplier);\n\t}\n\n\t/**\n\t* @notice Allows user to stake an nft to an existing stake for extra reward\n\t* @dev The stake should exist\n\t* @dev when adding the NFT we need to simulate an untake/stake because we need to recalculate the\n\t* new historyAverageAmount, stakingInfo.totalStakingUnits and stakingInfo.historyRewardPot\n\t* @notice it MUST revert if the added token has no multiplier\n\t*/\n\tfunction addNftToStake(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex,\n\t\taddress tokenAddress,\n\t\tuint256 tokenId\n\t)\n\t\tpublic\n\t{\n\t\tuint256 previousStakingUnits = userStakes[stakeIndex].stakingUnits; // this stays the same\n\t\trequire(previousStakingUnits > 0, \"Staking: Stake not found\");\n\n\t\tuint256 stakerReward = _getStakerReward(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\n\n\t\t_addNftToStakeAndApplyMultiplier(\n\t\t\tstakingInfo.rarityRegister,\n\t\t\tuserStakes[stakeIndex],\n\t\t\ttokenAddress,\n\t\t\ttokenId\n\t\t);\n\n\n\t\tuint256 newStakingUnits = userStakes[stakeIndex].stakingUnits; // after we just update it\n\n\t\tupdateHistoryValues(rewardStreamInfo, stakingInfo);\n\n\t\t// we bring the stake to the current time\n\t\tuserStakes[stakeIndex].enteredAtBlock = block.number;\n\t\tuserStakes[stakeIndex].historyAverageRewardWhenEntered = stakingInfo.historyAverageReward;\n\t\tuserStakes[stakeIndex].rewardCredit = stakerReward;\n\n\t\tstakingInfo.totalStakingUnits = stakingInfo.totalStakingUnits\n\t\t\t.sub(previousStakingUnits)\n\t\t\t.add(newStakingUnits);\n\n\t\tstakingInfo.historyRewardPot = stakingInfo.historyRewardPot.sub(stakerReward);\n\t}\n\n\tfunction _resetStake(UserStake storage userStake) private {\n\t\tuserStake.stakingUnits = 0;\n\t\tuserStake.rewardCredit = 0;\n\t\tuserStake.amountStaked = 0;\n\t\tuserStake.enteredAtBlock = 0;\n\t\tuserStake.lockedTill = 0;\n\t\tuserStake.ticketsMintingRatioWhenEntered = 0;\n\t\tuserStake.historyAverageRewardWhenEntered = 0;\n\t\tuserStake.ticketsMintingChillPeriodWhenEntered = 0;\n\t}\n\n\n\t/**\n\t* @notice Remove the preveusly staked NFT from the stake\n\t* @param staker the address of the owner of the stake\n\t*/\n\tfunction removeNftFromStake(\n\t\tUserStakedToken storage userStakedToken,\n\t\taddress staker\n\t)\n\t\tpublic\n\t{\n\t\tif (userStakedToken.tokenAddress != address(0)) {\n\t\t\tuint256 tokenId = userStakedToken.tokenId;\n\t\t\taddress tokenAddress = userStakedToken.tokenAddress;\n\n\t\t\tTokenHelper.transferFrom(tokenAddress, tokenId, address(this), staker);\n\t\t}\n\t}\n\n\t\t/**\n\t* @notice Allows user to unstake the staked tokens\n\t* @notice The tokens are allowed to be unstaked only after the lock duration has passed\n\t* @notice MUST trigger Unstaked event\n\t* @dev Unstaking tokens is an atomic operation—either all of the tokens in a stake, or none of the tokens.\n\t* @dev Users can only unstake a single stake at a time, it is must be their oldest active stake. Upon releasing that stake, the tokens will be\n\t*   transferred back to their account, and their personalStakeIndex will increment to the next active stake.\n\t* @return uint256 The number of tokens unstaked\n\t*/\n\tfunction unstake(\n\t\tRewardStreamerLib.RewardStreamInfo storage rewardStreamInfo,\n\t\tStakingInfo storage stakingInfo,\n\t\tUserStake[] storage userStakes,\n\t\tuint256 stakeIndex\n\t)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\trequire(stakeIndex < userStakes.length, 'Staking: Nothing to unstake');\n\n\t\trequire(userStakes[stakeIndex].lockedTill < block.number, \"Staking: Stake is still locked\");\n\t\trequire(userStakes[stakeIndex].amountStaked != 0, 'Staking: Nothing to unstake');\n\n\t\tuint256 stakerReward = _getStakerReward(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\tuserStakes,\n\t\t\tstakeIndex\n\t\t);\n\n\n\t\t// if for any reason the transfer fails, it will fail silently\n\t\t// and token can be withdrawn when error disappears\n\t\tremoveNftFromStake(userStakes[stakeIndex].userStakedToken, msg.sender);\n\n\n\t\tuint256 totalAmount = stakerReward\n\t\t\t.add(userStakes[stakeIndex].amountStaked)\n\t\t\t.add(userStakes[stakeIndex].rewardCredit);\n\n\t\tTokenHelper.ERC20Transfer(rewardStreamInfo.rewardToken, address(msg.sender), totalAmount);\n\n\t\tupdateHistoryValues(rewardStreamInfo, stakingInfo);\n\n\t\tstakingInfo.totalDistributedRewards = stakingInfo.totalDistributedRewards.add(stakerReward).add(userStakes[stakeIndex].rewardCredit);\n\t\tstakingInfo.totalCurrentlyStaked = stakingInfo.totalCurrentlyStaked.sub(userStakes[stakeIndex].amountStaked);\n\t\tstakingInfo.totalStakingUnits = stakingInfo.totalStakingUnits.sub(userStakes[stakeIndex].stakingUnits);\n\n\t\tclaimTickets(stakingInfo.ticket, userStakes[stakeIndex], msg.sender);\n\t\t_resetStake(userStakes[stakeIndex]);\n\n\t\tstakingInfo.historyRewardPot = stakingInfo.historyRewardPot.sub(stakerReward);\n\n\t\treturn stakerReward;\n\t}\n\n\tfunction getClaimableTickets(\n\t\tUserStake storage userStake\n\t)\n\t\tpublic\n\t  view\n\t\treturns (uint256)\n\t{\n\t\tuint256 stakingUnits = userStake.stakingUnits;\n\t\tuint256 ticketsMintingChillPeriod = userStake.ticketsMintingChillPeriodWhenEntered;\n\t\tuint256 ticketsMintingRatio = userStake.ticketsMintingRatioWhenEntered;\n\t\tuint256 ticketsMinted = userStake.ticketsMinted;\n\n\t\tif(stakingUnits == 0 || ticketsMintingRatio == 0 || ticketsMintingChillPeriod == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t// 2. get chilling period length\n\t\t// 3. check how many periods have passed\n\t\tuint256 enteredAtBlock = userStake.enteredAtBlock;\n\t\tuint256 lockedTill = userStake.lockedTill;\n\t\t// 4. prevent minting more tickets after stake is unlocked\n\n\t\tuint256 blocksDelta = Math.min(\n\t\t\t(uint256(block.number).sub(enteredAtBlock)),\n\t\t\t(lockedTill.sub(enteredAtBlock))\n\t\t).add(ticketsMintingChillPeriod); // count as passed from day 0\n\t\tuint256 periodsPassed = blocksDelta.div(ticketsMintingChillPeriod);\n\t\t// 4. multiply tickets\n\t\tuint256 multipliedUnits = stakingUnits.mul(periodsPassed);\n\t\t// 5. get printable tickets\n\t\tuint256 printableTickets = multipliedUnits.div(ticketsMintingRatio);\n\t\t// 6. subtract any previously minted\n\t\tuint256 netPrintableTickets = printableTickets.sub(ticketsMinted);\n\t\t// 5. don't print more tickets after stake is unlocked\n\t\treturn netPrintableTickets;\n \t}\n\n\t/**\n\t* @notice Mint tickets to the staker\n\t* @notice The amount of tickets depends on the amount of tokens staked and the duration the tokens a locked for.\n\t* @param ticket the address of the ticket instance\n\t* @param userStake the stake to claim tickets from\n\t* @param staker the address fo the staker\n\t*/\n\tfunction claimTickets(\n\t\taddress ticket,\n\t\tUserStake storage userStake,\n\t\taddress staker\n\t)\n\t\tpublic\n\t{\n\t\tuint256 netPrintableTickets = getClaimableTickets(userStake);\n\n\t\tif(netPrintableTickets > 0) {\n\t\t\t \n\t\t\tTokenHelper._mintTickets(ticket, staker, netPrintableTickets);\n\t\t\tuserStake.ticketsMinted = userStake.ticketsMinted.add(netPrintableTickets);\n\t\t}\n \t}\n}"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute.\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/Raffle/IRaffleTicket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n\n/// @title A mintable NFT ticekt for Coinburp Raffle\n/// @author Gilbert Kim @gilbertk422\ninterface IRaffleTicket is IERC1155 {\n\tfunction mint(address to, uint256 tokenId, uint256 amount) external;\n}\n"
    },
    "contracts/Staking/RewardStreamerLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./TokenHelper.sol\";\n\nlibrary RewardStreamerLib {\n\tusing SafeMath for uint256;\n\n\tstruct RewardStreamInfo {\n\t\tRewardStream[] rewardStreams;\n\t\tuint256 rewardStreamsLength;\n\t\tuint256 deployedAtBlock;\n\t\taddress rewardToken;\n\t}\n\n\tstruct RewardStream {\n\t\tuint256[] periodRewards;\n\t\tuint256[] periodEnds;\n\t\tuint256 rewardStreamCursor;\n\t}\n\n\t/**\n\t* @notice Will setup the token to use for reward\n\t* @param rewardTokenAddress The reward token address\n\t*/\n\tfunction setRewardToken(RewardStreamInfo storage rewardStreamInfo, address rewardTokenAddress) public {\n\t\trewardStreamInfo.rewardToken = address(rewardTokenAddress);\n\t}\n\n\t/**\n\t* @notice Will create a new rewad stream\n\t* @param rewardStreamIndex The reward index\n\t* @param rewardPerBlock The amount of tokens rewarded per block\n\t* @param rewardLastBlock The last block of the period\n\t*/\n\tfunction addRewardStream(\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint256 rewardStreamIndex,\n\t\tuint256 rewardPerBlock,\n\t\tuint256 rewardLastBlock\n\t)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\t// e.g. current length = 0 and we add index 1\n\t\trequire(rewardStreamIndex < rewardStreamInfo.rewardStreams.length.add(1), \"RewardStreamer: you cannot skip an index\");\n\n\t\tuint256 tokensInReward;\n\n\t\tif(rewardStreamInfo.rewardStreams.length > rewardStreamIndex) {\n\t\t\tRewardStream storage rewardStream = rewardStreamInfo.rewardStreams[rewardStreamIndex];\n\t\t\tuint256[] storage periodEnds = rewardStream.periodEnds;\n\n\t\t\tuint periodStart = periodEnds.length == 0\n\t\t\t\t? rewardStreamInfo.deployedAtBlock\n\t\t\t\t: periodEnds[periodEnds.length - 1];\n\n\t\t\trequire(periodStart < rewardLastBlock, \"RewardStreamer: periodStart must be smaller than rewardLastBlock\");\n\n\t\t\trewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds.push(rewardLastBlock);\n\t\t\trewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards.push(rewardPerBlock);\n\n\t\t\ttokensInReward = (rewardLastBlock.sub(periodStart)).mul(rewardPerBlock);\n\t\t} else {\n\t\t\tRewardStream memory rewardStream;\n\n\t\t\tuint periodStart = rewardStreamInfo.deployedAtBlock;\n\t\t\trequire(periodStart < rewardLastBlock, \"RewardStreamer: periodStart must be smaller than rewardLastBlock\");\n\n\t\t\trewardStreamInfo.rewardStreams.push(rewardStream);\n\t\t\trewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds.push(rewardLastBlock);\n\t\t\trewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards.push(rewardPerBlock);\n\n\t\t\ttokensInReward = (rewardLastBlock.sub(periodStart)).mul(rewardPerBlock);\n\t\t}\n\n\t\tTokenHelper.ERC20TransferFrom(address(rewardStreamInfo.rewardToken), msg.sender, address(this), tokensInReward);\n\n\t\treturn tokensInReward;\n\t}\n\n\t/**\n\t* @notice Get the rewards for a period\n\t* @param fromBlock the block number from which the reward is calculated\n\t* @param toBlock the block number till which the reward is calculated\n\t* @return (uint256) the total reward\n\t*/\n\tfunction unsafeGetRewardsFromRange(\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint fromBlock,\n\t\tuint toBlock\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\trequire(!_isContract(msg.sender), \"StakingReward: unsafe function for contract call\");\n\n\t\tuint256 currentReward;\n\n\t\tfor(uint256 i; i < rewardStreamInfo.rewardStreams.length; i++) {\n\t\t\tcurrentReward = currentReward.add(iterateRewards(\n\t\t\t\trewardStreamInfo,\n\t\t\t\ti,\n\t\t\t\tMath.max(fromBlock, rewardStreamInfo.deployedAtBlock),\n\t\t\t\ttoBlock,\n\t\t\t\t0\n\t\t\t));\n\t\t}\n\n\t\treturn currentReward;\n\t}\n\n\t/**\n\t* @notice Iterate the rewards\n\t* @param rewardStreamIndex the index of the reward stream\n\t* @param fromBlock the block number from which the reward is calculated\n\t* @param toBlock the block number till which the reward is calculated\n\t* @param rewardIndex the ireward index\n\t* @return (uint256) the calculate reward\n\t*/\n\tfunction iterateRewards(\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint256 rewardStreamIndex,\n\t\tuint fromBlock,\n\t\tuint toBlock,\n\t\tuint256 rewardIndex\n\t)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\t// the start block is bigger than\n\t\tif(rewardIndex >= rewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint currentPeriodEnd = rewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds[rewardIndex];\n\t\tuint currentPeriodReward = rewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards[rewardIndex];\n\n\t\tuint256 totalReward = 0;\n\n\t\t// what's the lowest block in current period?\n\t\tuint currentPeriodStart = rewardIndex == 0\n\t\t\t? rewardStreamInfo.deployedAtBlock\n\t\t\t: rewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds[rewardIndex - 1];\n\t\t// is the fromBlock included in period?\n\t\tif(fromBlock <= currentPeriodEnd) {\n\t\t\tuint256 lower = Math.max(fromBlock, currentPeriodStart);\n\t\t\tuint256 upper = Math.min(toBlock, currentPeriodEnd);\n\n\t\t\tuint256 blocksInPeriod = upper.sub(lower);\n\t\t\ttotalReward = blocksInPeriod.mul(currentPeriodReward);\n\t\t} else {\n\t\t\treturn iterateRewards(\n\t\t\t\trewardStreamInfo,\n\t\t\t\trewardStreamIndex,\n\t\t\t\tfromBlock,\n\t\t\t\ttoBlock,\n\t\t\t\trewardIndex.add(1)\n\t\t\t);\n\t\t}\n\n\t\tif(toBlock > currentPeriodEnd) {\n\t\t\t// we need to move to next reward period\n\t\t\ttotalReward += iterateRewards(\n\t\t\t\trewardStreamInfo,\n\t\t\t\trewardStreamIndex,\n\t\t\t\tfromBlock,\n\t\t\t\ttoBlock,\n\t\t\t\trewardIndex.add(1)\n\t\t\t);\n\t\t}\n\n\t\treturn totalReward;\n\t}\n\n\tfunction getRewardAndUpdateCursor (\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint256 fromBlock,\n\t\tuint256 toBlock\n\t)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\tuint256 currentReward;\n\n\t\tfor(uint256 i; i < rewardStreamInfo.rewardStreams.length; i++) {\n\t\t\tcurrentReward = currentReward.add(iterateRewardsWithCursor(\n\t\t\t\trewardStreamInfo,\n\t\t\t\ti,\n\t\t\t\tMath.max(fromBlock, rewardStreamInfo.deployedAtBlock),\n\t\t\t\ttoBlock,\n\t\t\t\trewardStreamInfo.rewardStreams[i].rewardStreamCursor\n\t\t\t));\n\t\t}\n\n\t\treturn currentReward;\n\t}\n\n\tfunction bumpStreamCursor(\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint256 rewardStreamIndex\n\t)\n\t\tpublic\n\t{\n\t\t// this step is important to avoid going out of index\n\t\tif(rewardStreamInfo.rewardStreams[rewardStreamIndex].rewardStreamCursor < rewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards.length) {\n\t\t\trewardStreamInfo.rewardStreams[rewardStreamIndex].rewardStreamCursor = rewardStreamInfo.rewardStreams[rewardStreamIndex].rewardStreamCursor.add(1);\n\t\t}\n\t}\n\n\tfunction iterateRewardsWithCursor(\n\t\tRewardStreamInfo storage rewardStreamInfo,\n\t\tuint256 rewardStreamIndex,\n\t\tuint fromBlock,\n\t\tuint toBlock,\n\t\tuint256 rewardPeriodIndex\n\t)\n\t\tpublic\n\t\treturns (uint256)\n\t{\n\t\tif(rewardPeriodIndex >= rewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards.length) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint currentPeriodEnd = rewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds[rewardPeriodIndex];\n\t\tuint currentPeriodReward = rewardStreamInfo.rewardStreams[rewardStreamIndex].periodRewards[rewardPeriodIndex];\n\n\t\tuint256 totalReward = 0;\n\n\t\t// what's the lowest block in current period?\n\t\tuint currentPeriodStart = rewardPeriodIndex == 0\n\t\t\t? rewardStreamInfo.deployedAtBlock\n\t\t\t: rewardStreamInfo.rewardStreams[rewardStreamIndex].periodEnds[rewardPeriodIndex - 1];\n\n\t\t// is the fromBlock included in period?\n\t\tif(fromBlock <= currentPeriodEnd) {\n\t\t\tuint256 lower = Math.max(fromBlock, currentPeriodStart);\n\t\t\tuint256 upper = Math.min(toBlock, currentPeriodEnd);\n\n\t\t\tuint256 blocksInPeriod = upper.sub(lower);\n\n\t\t\ttotalReward = blocksInPeriod.mul(currentPeriodReward);\n\t\t} else {\n\t\t\t// the fromBlock passed this reward period, we can start\n\t\t\t// skipping it for next reads\n\t\t\tbumpStreamCursor(rewardStreamInfo, rewardStreamIndex);\n\n\t\t\treturn iterateRewards(rewardStreamInfo, rewardStreamIndex, fromBlock, toBlock, rewardPeriodIndex.add(1));\n\t\t}\n\n\t\tif(toBlock > currentPeriodEnd) {\n\t\t\t// we need to move to next reward period\n\t\t\ttotalReward += iterateRewards(rewardStreamInfo, rewardStreamIndex, fromBlock, toBlock, rewardPeriodIndex.add(1));\n\t\t}\n\n\t\treturn totalReward;\n\t}\n\n\t/**\n\t* @dev Returns true if `account` is a contract.\n\t* @param account the address to check\n\t* @return (bool) if the account is a contract\n\t*/\n\tfunction _isContract(address account) public view returns (bool) {\n\t\t\t// This method relies on extcodesize, which returns 0 for contracts in\n\t\t\t// construction, since the code is only stored at the end of the\n\t\t\t// constructor execution.\n\n\t\t\tuint256 size;\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly { size := extcodesize(account) }\n\t\t\treturn size > 0;\n\t}\n}"
    },
    "contracts/Staking/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\nimport \"../Raffle/IRaffleTicket.sol\";\n\nlibrary TokenHelper {\n\tfunction ERC20Transfer(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t)\n\t\tpublic\n\t{\n\t\t(bool success, bytes memory data) =\n\t\t\t\ttoken.call(abi.encodeWithSelector(IERC20.transfer.selector, to, amount));\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), 'ERC20: transfer amount exceeds balance');\n\t}\n\n    function ERC20TransferFrom(\n\t\t\taddress token,\n\t\t\taddress from,\n\t\t\taddress to,\n\t\t\tuint256 amount\n    )\n\t\t\tpublic\n\t\t{\n\t\t\t(bool success, bytes memory data) =\n\t\t\t\t\ttoken.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount));\n\t\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), 'ERC20: transfer amount exceeds balance or allowance');\n    }\n\n    function transferFrom(\n        address token,\n        uint256 tokenId,\n        address from,\n        address to\n    )\n            public\n            returns (bool)\n        {\n                token.call(abi.encodeWithSelector(IERC721.transferFrom.selector, from, to, tokenId));\n\n                // in the ERC721 the transfer doesn't return a bool. So we need to check explicitly.\n                (, bytes memory data) = token\n                    .call(abi.encodeWithSelector(IERC721.ownerOf.selector, tokenId));\n\n                return abi.decode(data, (address)) == address(this);\n    }\n\n    function _mintTickets(\n        address ticket,\n        address to,\n        uint256 amount\n    ) public {\n        ticket.call(abi.encodeWithSelector(IRaffleTicket.mint.selector, to, 0, amount));\n    }\n}"
    },
    "contracts/Staking/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"./ERC900.sol\";\nimport \"./RewardStreamer.sol\";\nimport \"./StakingLib.sol\";\n\n/// @title A Staking smart contract\n/// @author Gilbert Kim @gilbertk422\ncontract Staking is Initializable, ERC900, OwnableUpgradeable, RewardStreamer {\n\tusing SafeMath for uint256;\n\n\tStakingLib.StakingInfo stakingInfo;\n\n\tmapping(address => StakingLib.UserStake[]) private _userStakes;\n\n\t/**\n\t * Constructor\n\t * @param _rewardToken The reward token address\n\t * @param _ticket The raffle ticket address\n\t * @param _locks The array with the locks durations values\n\t * @param _rarityRegister The rarity register address\n\t */\n\tfunction initialize (\n\t\taddress _rewardToken,\n\t\taddress _ticket,\n\t\tuint256[] memory _locks,\n\t\tuint256[] memory _locksMultiplier,\n\t\tuint256 _ticketsMintingRatio,\n\t\taddress _rarityRegister,\n\t\taddress _defaultStaker\n\t) public initializer {\n\t\trequire(_locks.length == _locksMultiplier.length, 'Stake: lock multiplier should have the same length ad locks');\n\t\tOwnableUpgradeable.__Ownable_init();\n\n\t\tsuper._setRewardToken(_rewardToken);\n\n\t\t// add the default staker. we need a default staker to neveer have 0 staking units\n\t\t_addStaker(_defaultStaker, 1 * 10**18, block.number.add(1), 0);\n\n\t\tstakingInfo.totalStakingUnits = stakingInfo.totalStakingUnits.add(1 * 10 ** 18);\n\t\tstakingInfo.totalCurrentlyStaked = stakingInfo.totalCurrentlyStaked.add(1 * 10 ** 18);\n\n\t\tstakingInfo.locks = _locks;\n\t\tstakingInfo.locksMultiplier = _locksMultiplier;\n\t\tstakingInfo.historyStartBlock = block.number;\n\t\tstakingInfo.historyEndBlock = block.number;\n\n\t\tsetTicketsMintingChillPeriod(1);\n\t\tsetTicketsMintingRatio(_ticketsMintingRatio);\n\t\tsetTicket(_ticket);\n\t\tsetRarityRegister(_rarityRegister);\n\n\t\tRewardStreamer.rewardStreamInfo.deployedAtBlock = block.number;\n\t}\n\n\t/**\n\t* @notice Will create a new rewad stream\n\t* @param rewardStreamIndex The reward index\n\t* @param periodBlockRate The reward per block\n\t* @param periodLastBlock The last block of the period\n\t*/\n\tfunction addRewardStream(uint256 rewardStreamIndex, uint256 periodBlockRate, uint256 periodLastBlock) public onlyOwner {\n\t\tsuper._addRewardStream(rewardStreamIndex, periodBlockRate, periodLastBlock);\n\t}\n\n\t/**\n\t* @notice Will add a new lock duration value\n\t* @param lockNumber the new lock duration value\n\t*/\n\tfunction addLockDuration(uint256 lockNumber, uint256 lockMultiplier) public onlyOwner {\n\t\tstakingInfo.locks.push(lockNumber);\n\t\tstakingInfo.locksMultiplier.push(lockMultiplier);\n\n\t\temit LocksUpdated(stakingInfo.locks.length.sub(1), lockNumber, lockMultiplier);\n\t}\n\n\tevent LocksUpdated(uint256 lockIndex, uint256 lockNumber, uint256 lockMultiplier);\n\t/**\n\t* @notice Will update an existing lock value\n\t* @param lockIndex the lock index\n\t* @param lockNumber the new lock duration value\n\t*/\n\tfunction updateLocks(uint256 lockIndex, uint256 lockNumber, uint256 lockMultiplier) public onlyOwner {\n\t\tstakingInfo.locks[lockIndex] = lockNumber;\n\t\tstakingInfo.locksMultiplier[lockIndex] = lockMultiplier;\n\n\t\temit LocksUpdated(lockIndex, lockNumber, lockMultiplier);\n\t}\n\n\tevent TicketMintingChillPeriodUpdated(uint256 newValue);\n\n\t/**\n\t* @notice Will update the ticketsMintingChillPeriod\n\t* @param newTicketsMintingChillPeriod the new value\n\t*/\n\tfunction setTicketsMintingChillPeriod(uint256 newTicketsMintingChillPeriod) public onlyOwner {\n\t\trequire(newTicketsMintingChillPeriod > 0, \"Staking: ticketsMintingChillPeriod can't be zero\");\n\t\tstakingInfo.ticketsMintingChillPeriod = newTicketsMintingChillPeriod;\n\n\t\temit TicketMintingChillPeriodUpdated(newTicketsMintingChillPeriod);\n\t}\n\n\tevent TicketMintingRatioUpdated(uint256 newValue);\n\t/**\n\t* @notice Will update the numebr of stakingUnits needed to earn one ticket\n\t* @param newTicketsMintingRatio the new value\n\t*/\n\tfunction setTicketsMintingRatio(uint256 newTicketsMintingRatio) public onlyOwner {\n\t\tstakingInfo.ticketsMintingRatio = newTicketsMintingRatio;\n\n\t\temit TicketMintingRatioUpdated(newTicketsMintingRatio);\n\t}\n\n\t/**\n\t* @notice Will update the ticket address\n\t* @param ticketAddress the new value\n\t*/\n\tfunction setTicket(address ticketAddress) public onlyOwner {\n\t\tstakingInfo.ticket = ticketAddress;\n\t}\n\n\n\tevent RarityRegisterUpdated(address rarityRegister);\n\t/**\n\t* @notice Will update the rarityRegister address\n\t* @param newRarityRegister the new value\n\t*/\n\tfunction setRarityRegister(address newRarityRegister) public onlyOwner {\n\t\tstakingInfo.rarityRegister = newRarityRegister;\n\n\t\temit RarityRegisterUpdated(newRarityRegister);\n\t}\n\n\n\t/**\n\t* @notice Will calculate the total reward generated from start till now\n\t* @return (uint256) The the calculated reward\n\t*/\n\tfunction getTotalGeneratedReward() external view returns(uint256) {\n\t\treturn RewardStreamerLib.unsafeGetRewardsFromRange(rewardStreamInfo, stakingInfo.historyStartBlock, block.number);\n\t}\n\n\tfunction historyStartBlock() public view returns (uint256) {return stakingInfo.historyStartBlock;}\n\tfunction historyEndBlock() public view returns (uint256) {return stakingInfo.historyEndBlock;}\n\tfunction historyAverageReward() public view returns (uint256) {return stakingInfo.historyAverageReward;}\n\tfunction historyRewardPot() public view returns (uint256) {return stakingInfo.historyRewardPot;}\n\tfunction totalCurrentlyStaked() public view returns (uint256) {return stakingInfo.totalCurrentlyStaked;}\n\tfunction totalStakingUnits() public view returns (uint256) {return stakingInfo.totalStakingUnits;}\n\tfunction totalDistributedRewards() public view returns (uint256) {return stakingInfo.totalDistributedRewards;}\n\tfunction ticketsMintingRatio() public view returns (uint256) {return stakingInfo.ticketsMintingRatio;}\n\tfunction ticketsMintingChillPeriod() public view returns (uint256) {return stakingInfo.ticketsMintingChillPeriod;}\n\tfunction rarityRegister() public view returns (address) {return stakingInfo.rarityRegister;}\n\tfunction locks(uint256 i) public view returns (uint256) {return stakingInfo.locks[i];}\n\tfunction locksMultiplier(uint256 i) public view returns (uint256) {return stakingInfo.locksMultiplier[i];}\n\tfunction userStakes(address staker, uint256 i) public view returns (StakingLib.UserStake memory) {\n\t\tStakingLib.UserStake memory s;\n\n\t\treturn _userStakes[staker].length > i\n\t\t\t? _userStakes[staker][i]\n\t\t\t: s;\n\t}\n\tfunction userStakedTokens(address staker, uint256 stakeIndex) public view returns (StakingLib.UserStakedToken memory) {\n\t\tStakingLib.UserStakedToken memory s;\n\n\t\treturn _userStakes[staker].length > stakeIndex\n\t\t\t? _userStakes[staker][stakeIndex].userStakedToken\n\t\t\t: s;\n\t}\n\n\t/**\n\t* @notice Will calculate the current period length\n\t* @return (uint256) The current period length\n\t*/\n\tfunction getCurrentPeriodLength() public view returns(uint256) {\n\t\treturn StakingLib.getCurrentPeriodLength(stakingInfo);\n\t}\n\n\t/**\n\t* @notice Will calculate the current period total reward\n\t* @return (uint256) The current period total reward\n\t*/\n\tfunction getTotalRewardInCurrentPeriod() public view returns(uint256) {\n\t\treturn RewardStreamerLib.unsafeGetRewardsFromRange(rewardStreamInfo, stakingInfo.historyEndBlock, block.number);\n\t}\n\n\t/**\n\t* @notice Will calculate the current period average reward\n\t* @return (uint256) The current period average\n\t*/\n\tfunction getCurrentPeriodAverageReward() public view returns(uint256) {\n\t\treturn StakingLib.getCurrentPeriodAverageReward(\n\t\t\tstakingInfo,\n\t\t\tgetTotalRewardInCurrentPeriod(),\n\t\t\tfalse\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate the history length in blocks\n\t* @return (uint256) The history length\n\t*/\n\tfunction getHistoryLength() public view returns (uint256){\n\t\treturn StakingLib.getHistoryLength(stakingInfo);\n\t}\n\n\t/**\n\t* @notice Will get the pool share for a specific stake\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The userPoolShare\n\t*/\n\tfunction getStakerPoolShare(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.userPoolShare(\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex,\n\t\t\tstakingInfo.totalStakingUnits\n\t\t);\n\t}\n\n\n\t/**\n\t* @notice Will get the reward of a stake for the curent period\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The reward for current period\n\t*/\n\tfunction getStakerRewardFromCurrent(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getStakerRewardFromCurrentPeriod(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate and return for how many block the stake has in history\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The number of blocks in history\n\t*/\n\tfunction getStakerTimeInHistory(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getStakerTimeInHistory(\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate and return what the history length was a the moment the stake was created\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The length of the history\n\t*/\n\tfunction getHistoryLengthBeforeStakerEntered(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getHistoryLengthBeforeStakerEntered(\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate and return the history average for a stake\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The calculated history average\n\t*/\n\tfunction getHistoryAverageForStake(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getHistoryAverageForStaker(\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\t/**\n\t* @return (uint256) The number of all the stakes user has ever staked\n\t*/\n\tfunction getUserStakes(address staker) public view returns(uint256) {\n\t\treturn _userStakes[staker].length;\n\t}\n\n\t/**\n\t* @notice Will calculate and return the total reward user has accumulated till now for a specific stake\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @return (uint256) The total rewards acumulated till now\n\t*/\n\tfunction getStakerReward(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getStakerReward(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\t/**\n\t* @notice Will calculate the rewards that user will get from history\n\t* @param staker the address of the staker you wish to get the rewards\n\t* @param stakeIndex the index of the stake\n\t* @return uint256 The amount of tokes user will get from history\n\t*/\n\tfunction getStakerRewardFromHistory(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\treturn StakingLib.getStakerRewardFromHistory(\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex\n\t\t);\n\t}\n\n\tfunction getClaimableTickets(address staker, uint256 stakeIndex) public view returns (uint256) {\n\t\trequire(_userStakes[staker].length > stakeIndex, \"Staking: stake does not exist\");\n\n\t\treturn StakingLib.getClaimableTickets(\n\t\t\t_userStakes[staker][stakeIndex]\n\t\t);\n\t}\n\n\tfunction claimTickets(uint256 stakeIndex) public {\n\t\trequire(_userStakes[msg.sender].length > stakeIndex, \"Staking: stake does not exist\");\n\n\t\tStakingLib.claimTickets(\n\t\t\tstakingInfo.ticket,\n\t\t\t_userStakes[msg.sender][stakeIndex],\n\t\t\tmsg.sender\n\t\t);\n\t}\n\n\t/**\n\t* @notice Creates a stake instance for the staker\n\t* @notice MUST trigger Staked event\n\t* @dev The NFT should be in the rarityRegister\n\t* @dev For each stake you can have only one NFT staked\n\t* @param stakerAddress the address of the owner of the stake\n\t* @param amountStaked the number of tokens to be staked\n\t* @param blockNumber the block number at which the stake is created\n\t* @param lockDuration the duration for which the tokens will be locked\n\t*/\n\tfunction _addStaker(address stakerAddress, uint256 amountStaked, uint256 blockNumber, uint256 lockDuration) internal {\n\t\t_userStakes[stakerAddress].push(StakingLib.UserStake({\n\t\t\tamountStaked: amountStaked,\n\t\t\tstakingUnits: amountStaked,\n\t\t\tenteredAtBlock: blockNumber,\n\t\t\thistoryAverageRewardWhenEntered: stakingInfo.historyAverageReward,\n\t\t\tticketsMintingRatioWhenEntered: stakingInfo.ticketsMintingRatio,\n\t\t\tticketsMintingChillPeriodWhenEntered: stakingInfo.ticketsMintingChillPeriod,\n\t\t\tlockedTill: blockNumber.add(lockDuration),\n\t\t\trewardCredit: 0,\n\t\t\tticketsMinted: 0,\n\t\t\tuserStakedToken: StakingLib.UserStakedToken({\n\t\t\t\t\ttokenAddress: address(0),\n\t\t\t\t\ttokenId: 0\n\t\t\t\t})\n\t\t\t})\n\t\t);\n\n\t\temit Staked(stakerAddress, amountStaked, stakingInfo.totalCurrentlyStaked, abi.encodePacked(_userStakes[stakerAddress].length.sub(1)));\n\t}\n\n\t/**\n\t* @notice Allows user to stake tokens\n\t* @notice Optionaly user can stake a NFT token for extra reward\n\t* @dev Users wil be able to unstake only after the lock durationn has pased.\n\t* @dev The lock duration in the data bytes is required, its the index of the locks array\n\t* Should be the fist 32 bytes in the bytes array\n\t* @param amount the inumber of tokens to be staked\n\t* @param data the bytes containig extra information about the staking\n\t* lock duration index: fist 32 bytes (Number) - Required\n\t* NFT address: next 20 bytes (address)\n\t* NFT tokenId: next 32 bytes (Number)\n\t*/\n\tfunction stake(uint256 amount, bytes calldata data) public override {\n\t\tStakingLib.stake(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[msg.sender],\n\t\t\tmsg.sender,\n\t\t\tamount,\n\t\t\tdata\n\t\t);\n\n\t\temit Staked(\n\t\t\tmsg.sender,\n\t\t\tamount,\n\t\t\tstakingInfo.totalCurrentlyStaked,\n\t\t\tabi.encodePacked(_userStakes[msg.sender].length.sub(1))\n\t\t);\n\t}\n\n\t/**\n\t* @notice Stakes a certain amount of tokens, this MUST transfer the given amount from the caller\n\t* @notice MUST trigger Staked event\n\t* @param user the address the tokens are staked for\n\t* @param amount uint256 the amount of tokens to stake\n\t* @param data bytes aditional for the stake and to include in the Stake event\n\t* lock duration index: fist 32 bytes (Number) - Required\n\t* NFT address: next 20 bytes (address)\n\t* NFT tokenId: next 32 bytes (Number)\n\t*/\n\tfunction stakeFor(address user, uint256 amount, bytes calldata data) external override {\n\t\tStakingLib.stake(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[user],\n\t\t\tuser,\n\t\t\tamount,\n\t\t\tdata\n\t\t);\n\t\temit Staked(user, amount, stakingInfo.totalCurrentlyStaked, abi.encodePacked(_userStakes[user].length.sub(1)));\n\t}\n\n\t/**\n\t* @notice Allows user to stake an nft to an existing stake for extra reward\n\t* @dev The stake should exist\n\t* @dev when adding the NFT we need to simulate an untake/stake because we need to recalculate the\n\t* new historyAverageAmount, stakingInfo.totalStakingUnits and stakingInfo.historyRewardPot\n\t* @notice it MUST revert if the added token has no multiplier\n\t* @param staker the address of the owner of the stake\n\t* @param stakeIndex the index of the stake\n\t* @param tokenAddress the address of the NFT\n\t* @param tokenId the id of the NFT token\n\t*/\n\tfunction addNftToStake(address staker, uint256 stakeIndex, address tokenAddress, uint256 tokenId) public {\n\t\tStakingLib.addNftToStake(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[staker],\n\t\t\tstakeIndex,\n\t\t\ttokenAddress,\n\t\t\ttokenId\n\t\t);\n\t}\n\n\t/**\n\t* @notice Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert\n\t* @notice MUST trigger Unstaked event\n\t* @dev Unstaking tokens is an atomic operation—either all of the tokens in a stake, or none of the tokens.\n\t* @dev Users can only unstake a single stake at a time, it is must be their oldest active stake. Upon releasing that stake, the tokens will be\n\t*   transferred back to their account, and their personalStakeIndex will increment to the next active stake.\n\t* @param amount uint256 the amount of tokens to unstake\n\t* @param data bytes optional data to include in the Unstake event\n\t*/\n\tfunction unstake(uint256 amount, bytes calldata data) public override {\n\t\tuint256 stakerReward = StakingLib.unstake(\n\t\t\trewardStreamInfo,\n\t\t\tstakingInfo,\n\t\t\t_userStakes[msg.sender],\n\t\t\tStakingLib.getStakeIndexFromCalldata(data)\n\t\t);\n\n\t\temit Unstaked(\n\t\t\tmsg.sender,\n\t\t\tstakerReward,\n\t\t\tstakingInfo.totalCurrentlyStaked,\n\t\t\tabi.encodePacked(StakingLib.getStakeIndexFromCalldata(data))\n\t\t);\n\t}\n\n\t/**\n\t* @notice This function offers a way to withdraw a ERC721 after using failsafeUnstakeERC20.\n\t* @notice If for any reason the ERC721 should function again, this function allows to withdraw it.\n\t* @param data bytes optional data to include in the Unstake event\n\t*/\n\tfunction unstakeERC721(bytes calldata data) external {\n\t\tuint256 stakeIndex = StakingLib.getStakeIndexFromCalldata(data);\n\t\trequire(_userStakes[msg.sender][stakeIndex].lockedTill < block.number, \"Staking: Stake is still locked\");\n\n\t\tStakingLib.removeNftFromStake(\n\t\t\t_userStakes[msg.sender][stakeIndex].userStakedToken,\n\t\t\tmsg.sender\n\t\t);\n\t}\n\n\t/**\n\t* @notice Returns the current total of tokens staked for an address\n\t* @param staker address The address to query\n\t* @return uint256 The number of tokens staked for the given address\n\t*/\n\tfunction totalStakedFor(address staker) external override view returns (uint256) {\n\t\treturn StakingLib.getTotalStakedFor(_userStakes[staker]);\n\t}\n\n\t/**\n\t* @notice Returns the current total of tokens staked\n\t* @return uint256 The number of tokens staked in the contract\n\t*/\n\tfunction totalStaked() external override view returns (uint256) {\n\t\treturn stakingInfo.totalCurrentlyStaked;\n\t}\n\n\t/**\n\t* @notice MUST return true if the optional history functions are implemented, otherwise false\n\t* @dev Since we don't implement the optional interface, this always returns false\n\t* @return bool Whether or not the optional history functions are implemented\n\t*/\n\tfunction supportsHistory() external override pure returns (bool) {\n\t\treturn false;\n\t}\n\n\t/**\n\t* @notice Address of the token being used by the staking interface\n\t* @return address The address of the ERC20 token used for staking\n\t*/\n\tfunction token() external override view returns (address) {\n\t\treturn address(rewardStreamInfo.rewardToken);\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/Staking/ERC900.sol": {
      "content": "/* solium-disable */\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC900 Simple Staking Interface\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-900.md\n */\ninterface ERC900 {\n\tevent Staked(address indexed user, uint256 amount, uint256 total, bytes data);\n\tevent Unstaked(address indexed user, uint256 amount, uint256 total, bytes data);\n\n\tfunction stake(uint256 amount, bytes calldata data) external;\n\tfunction stakeFor(address user, uint256 amount, bytes calldata data) external;\n\tfunction unstake(uint256 amount, bytes calldata data) external;\n\tfunction totalStakedFor(address addr) external view returns (uint256);\n\tfunction totalStaked() external view returns (uint256);\n\tfunction token() external view returns (address);\n\tfunction supportsHistory() external pure returns (bool);\n\n\t// NOTE: Not implementing the optional functions\n\t// function lastStakedFor(address addr) public view returns (uint256);\n\t// function totalStakedForAt(address addr, uint256 blockNumber) public view returns (uint256);\n\t// function totalStakedAt(uint256 blockNumber) public view returns (uint256);\n}"
    },
    "contracts/Staking/RewardStreamer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./RewardStreamerLib.sol\";\n\n\n/// @title A Staking smart contract\n/// @author Gilbert Kim @gilbertk422\ncontract RewardStreamer {\n\n\tRewardStreamerLib.RewardStreamInfo public rewardStreamInfo;\n\n\tevent RewardStreamAdded(uint256 rewardPerBlock, uint256 rewardLastBlock, uint256 rewardInStream);\n\n\tfunction rewardToken() public view returns (address) {return address(rewardStreamInfo.rewardToken);}\n\n\t/**\n\t* @notice Will setup the token to use for reward\n\t* @param rewardTokenAddress The reward token address\n\t*/\n\tfunction _setRewardToken(address rewardTokenAddress) internal {\n\t\tRewardStreamerLib.setRewardToken(rewardStreamInfo, rewardTokenAddress);\n\t}\n\n\t/**\n\t* @notice Will create a new rewad stream\n\t* @param rewardStreamIndex The reward index\n\t* @param rewardPerBlock The amount of tokens rewarded per block\n\t* @param rewardLastBlock The last block of the period\n\t*/\n\tfunction _addRewardStream(uint256 rewardStreamIndex, uint256 rewardPerBlock, uint256 rewardLastBlock) internal {\n\t\tuint256 tokensInReward = RewardStreamerLib.addRewardStream(\n\t\t\trewardStreamInfo,\n\t\t\trewardStreamIndex,\n\t\t\trewardPerBlock,\n\t\t\trewardLastBlock\n\t\t);\n\n\t\temit RewardStreamAdded(rewardPerBlock, rewardLastBlock, tokensInReward);\n\t}\n\n\t/**\n\t* @notice Iterate the rewards\n\t* @param rewardStreamIndex the index of the reward stream\n\t* @param fromBlock the block number from which the reward is calculated\n\t* @param toBlock the block number till which the reward is calculated\n\t* @param rewardIndex the ireward index\n\t* @return (uint256) the calculate reward\n\t*/\n\tfunction _iterateRewards(uint256 rewardStreamIndex, uint fromBlock, uint toBlock, uint256 rewardIndex) internal view returns (uint256) {\n\t\treturn RewardStreamerLib.iterateRewards(\n\t\t\trewardStreamInfo,\n\t\t\trewardStreamIndex,\n\t\t\tfromBlock,\n\t\t\ttoBlock,\n\t\t\trewardIndex\n\t\t);\n\t}\n\n\tfunction _bumpStreamCursor(uint256 rewardStreamIndex) private {\n\t\tRewardStreamerLib.bumpStreamCursor(rewardStreamInfo, rewardStreamIndex);\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Mocks/MockERC721Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\n/// @title Lottery tickets to be given to users after staking (mintable).\n/// @author Gilbert Kim @gilbertk422\ncontract MockERC721Token is ERC721, Ownable, Pausable {\n\n\tconstructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\n\n\t/**\n\t * @dev Function to mint tokens.\n\t * @param to The address that will receive the minted tokens.\n\t * @param tokenId The token id to mint.\n\t * @return A boolean that indicates if the operation was successful.\n\t */\n\tfunction mint(address to, uint256 tokenId) public returns (bool) {\n\t\tsuper._safeMint(to, tokenId);\n\t\treturn true;\n\t}\n\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public override whenNotPaused {\n\t\tsuper.safeTransferFrom(from, to, tokenId);\n\t}\n\tfunction transferFrom(address from, address to, uint256 tokenId) public override whenNotPaused {\n\t\tsuper.transferFrom(from, to, tokenId);\n\t}\n\n\tfunction pause() public {\n\t\t_pause();\n\t}\n\t\n\tfunction unpause() public {\n\t\t_unpause();\n\t}\n\n}"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20Capped is ERC20 {\n    uint256 private immutable _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor(uint256 cap_) {\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n}\n"
    },
    "contracts/Mocks/MockReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MockReward is Ownable, ERC20Capped {\n\tuint256 constant CAP = 100e24; // 100 million\n\n\tconstructor() ERC20(\"Reward\", \"BR\") ERC20Capped(CAP) {}\n\n\t/**\n\t * @notice Allow the owner to mint tokens\n\t * @param to Address that will receive the minted tokens\n\t * @param amount Amount of tokens that will be minted\n\t */\n\tfunction mint(address to, uint256 amount) public onlyOwner {\n\t\t_mint(to, amount);\n\t}\n}\n"
    },
    "contracts/Mocks/MockStakingReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../Staking/RewardStreamer.sol\";\nimport \"../Staking/StakingLib.sol\";\n\n\n/// @title A Mock for the Staking Reward contract\n/// @author Gilbert Kim @gilbertk422\ncontract MockStakingReward is RewardStreamer {\n\tuint256 public returnedValue;\n\n\tconstructor(address _token) {\n\t\tsuper._setRewardToken(_token);\n\t\tRewardStreamer.rewardStreamInfo.deployedAtBlock = block.number;\n\t}\n\n\tfunction addRewardStream(uint256 rewardStreamIndex, uint256 periodBlockRate, uint256 periodLastBlock) public {\n\t\tsuper._addRewardStream(rewardStreamIndex, periodBlockRate, periodLastBlock);\n\t}\n\n\tfunction rewardStreamCursors(uint256 rewardStreamIndex) public view returns (uint256) {\n\t\treturn rewardStreamInfo.rewardStreams[rewardStreamIndex].rewardStreamCursor;\n\t}\n\n\tfunction getRewardsFromRange(uint fromBlock, uint toBlock) public view returns (uint256) {\n\t\treturn RewardStreamerLib.unsafeGetRewardsFromRange(\n\t\t\trewardStreamInfo,\n\t\t\tfromBlock,\n\t\t\ttoBlock\n\t\t);\n\t}\n\n\tfunction storeRewardValue(uint256 fromBlock, uint256 toBlock) external {\n\t\treturnedValue = RewardStreamerLib.getRewardAndUpdateCursor(rewardStreamInfo, fromBlock, toBlock);\n\t}\n}\n"
    },
    "contracts/Mocks/MockStakingV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"../Staking/StakingLib.sol\";\nimport \"../Staking/Staking.sol\";\n\n/// @title A Mock upgrade for the Staking contract\n/// @author Gilbert Kim @gilbertk422\ncontract MockStakingV2 is Staking {\n\tfunction echo(uint256 v) public view returns (uint256) {\n\t\treturn v;\n\t}\n\n\tfunction newGetHistoryLength() public view returns (uint256) {\n\t\treturn 4242;\n\t}\n}\n"
    },
    "contracts/Chainlink/vendor/BasicToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public virtual returns (bool) {\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of. \n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n"
    },
    "contracts/Chainlink/vendor/StandardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport { BasicToken as linkBasicToken } from \"./BasicToken.sol\";\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is linkBasicToken {\n\n\tusing SafeMath for uint256;\n\n\tmapping (address => mapping (address => uint256)) allowed;\n\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool) {\n\t\tuint256 _allowance = allowed[_from][msg.sender];\n\n\t\t// Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n\t\t// require (_value <= _allowance);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public virtual returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\t\n\t\t/*\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until \n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t */\n\tfunction increaseApproval (address _spender, uint _addedValue) public returns (bool success) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\tfunction decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n"
    },
    "contracts/Chainlink/Mocks/LinkToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nimport \"./ERC677Token.sol\";\nimport { StandardToken as linkStandardToken } from \"../vendor/StandardToken.sol\";\n\n\ncontract LinkToken is linkStandardToken, ERC677Token {\n\n\tuint256 public totalSupply = 10**27;\n\tstring public constant name = \"ChainLink Token\";\n\tuint8 public constant decimals = 18;\n\tstring public constant symbol = \"LINK\";\n\n\tconstructor() {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\n\t/**\n\t* @dev transfer token to a specified address with additional data if the recipient is a contract.\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t* @param _data The extra data to be passed to the receiving contract.\n\t*/\n\tfunction transferAndCall(address _to, uint _value, bytes memory _data)\n\t\tpublic\n\t\toverride\n\t\tvalidRecipient(_to)\n\t\treturns (bool success)\n\t{\n\t\treturn super.transferAndCall(_to, _value, _data);\n\t}\n\n\t/**\n\t* @dev transfer token to a specified address.\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint _value)\n\t\tpublic\n\t\toverride\n\t\tvalidRecipient(_to)\n\t\treturns (bool success)\n\t{\n\t\treturn super.transfer(_to, _value);\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value)\n\t\tpublic\n\t\toverride\n\t\tvalidRecipient(_spender)\n\t\treturns (bool)\n\t{\n\t\treturn super.approve(_spender,  _value);\n\t}\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value)\n\t\tpublic\n\t\toverride\n\t\tvalidRecipient(_to)\n\t\treturns (bool)\n\t{\n\t\treturn super.transferFrom(_from, _to, _value);\n\t}\n\n\n\t// MODIFIERS\n\n\tmodifier validRecipient(address _recipient) {\n\t\trequire(_recipient != address(0) && _recipient != address(this), 'LinkToken: Recipient not valid');\n\t\t_;\n\t}\n\n}\n"
    },
    "contracts/Chainlink/Mocks/ERC677Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\nimport \"../interfaces/IERC677.sol\";\nimport \"../interfaces/IERC677Receiver.sol\";\nimport \"../vendor/StandardToken.sol\";\n\n\ncontract ERC677Token is IERC677, StandardToken{\n\n\t/**\n\t* @dev transfer token to a contract address with additional data if the recipient is a contact.\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t* @param _data The extra data to be passed to the receiving contract.\n\t*/\n\tfunction transferAndCall(address _to, uint _value, bytes memory _data)\n\t\tpublic\n\t\toverride\n\t\tvirtual\n\t\treturns (bool success)\n\t{\n\t\tsuper.transfer(_to, _value);\n\t\tTransfer(msg.sender, _to, _value, _data);\n\t\tif (isContract(_to)) {\n\t\t\tcontractFallback(_to, _value, _data);\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t// PRIVATE\n\n\tfunction contractFallback(address _to, uint _value, bytes memory _data)\n\t\tpublic\n\t{\n\t\tIERC677Receiver receiver = IERC677Receiver(_to);\n\t\treceiver.onTokenTransfer(msg.sender, _value, _data);\n\t}\n\n\tfunction isContract(address _addr) private view returns (bool hasCode) {\n\t\tuint length;\n\t\tassembly { length := extcodesize(_addr) }\n\t\treturn length > 0;\n\t}\n\n}"
    },
    "contracts/Chainlink/interfaces/IERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677 {\n\tfunction transferAndCall(address to, uint value, bytes memory data) external returns (bool success);\n\n\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\n}"
    },
    "contracts/Chainlink/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\ninterface IERC677Receiver {\n\tfunction onTokenTransfer(address _sender, uint _value, bytes memory _data) external;\n}"
    },
    "contracts/Chainlink/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IERC20Basic as linkERC20Basic } from \"./IERC20Basic.sol\";\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is linkERC20Basic {\n\tfunction allowance(address owner, address spender) external returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\n\tfunction approve(address spender, uint256 value) external returns (bool);\n\t\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/Chainlink/interfaces/IERC20Basic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ninterface IERC20Basic {\n\tfunction balanceOf(address who) external returns (uint256);\n\tfunction transfer(address to, uint256 value) external  returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Migrations {\n\taddress public owner;\n\tuint public last_completed_migration;\n\n\tmodifier restricted() {\n\t\tif (msg.sender == owner) _;\n\t}\n\n\tconstructor() {\n\t\towner = msg.sender;\n\t}\n\n\tfunction setCompleted(uint completed) public restricted {\n\t\tlast_completed_migration = completed;\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}